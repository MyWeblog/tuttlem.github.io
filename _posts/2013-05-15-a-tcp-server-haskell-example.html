---
layout: post
title: A TCP Server Haskell Example
date: 2013-05-15
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3>In today's post, I'll demonstrate (and explain) how to put together a very simple TCP server in Haskell. The most simple example that I can think of, that will still leave you with enough skeleton to get up and running yourself is an echo server.<br /><br /><h3>The Functional Specification</h3>An Echo server. The drab, beige, sensible-older-brother in the server world. We'll accept incoming connections on a port and recite (echo) any data sent to us by the client. Simple.<br /><h3>Design</h3>Using the network, concurrency and system modules in Haskell, you're actually allowed a pretty simple and fluid design. Of course, you can make this as "one-liner" as you'd like, but for demonstration purposes today I'll break the server over a few parts:<br /><ul><li>Main program</li><li>Socket handler</li><li>Echo implementation</li></ul>The main program will take care of getting us out of first gear. It'll setup a listening socket (or server socket) and then hand off client connection responsibilities to the socket handler. The socket handler will then hand the client off to the echo implementation to work with as well as ensure it's ready for any extra connections. Finally, the echo implementation will just facilitate the server's functionality layer in. It will just send back to the client what ever it has given.<br /><h3>Code Walkthrough </h3>The main program is very simple. Setup the server socket using <a href="http://hackage.haskell.org/packages/archive/network/2.3.0.14/doc/html/Network.html#v:listenOn">listenOn</a> and then hand control over to the client handler.<br /><br /><script src="https://gist.github.com/tuttlem/5583842.js"></script> <br />The client handler (or socket handler as I called it above) accepts incoming client connections from the server socket using <a href="http://hackage.haskell.org/packages/archive/network/2.3.0.14/doc/html/Network.html#v:accept">accept</a>. We can then set buffering options (to off) for the client connection with <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering">hSetBuffering</a>. From there we make the echo service implementation fire up on a thread of its own with <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkIO">forkIO</a>. <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkIO">forkIO</a> deserves a blog post of its own (as does the Concurrency module as a whole), and it will get one... just not today. Anyway, finally the client handler recurses on itself to handle the next client.<br /><br />It's a lot of text for some pretty simple code in the end.<br /><br /><script src="https://gist.github.com/tuttlem/5583932.js"></script> <br />Finally, we have the actual implementation. This is the code that makes our server an echo server. We'll take a line of text in from the client socket using <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hGetLine">hGetLine</a> then we'll write it back to the client using <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hPutStrLn">hPutStrLn</a>.<br /><br /><script src="https://gist.github.com/tuttlem/5583956.js"></script> <br />And that's it. The full code listing for this echo server is below.<br /><br /><script src="https://gist.github.com/tuttlem/5583974.js"></script><br /><br /><h3>Final thoughts</h3>There is a fairly basic pattern that you can establish out of the module here that you can adapt for more complex servers of your own. Some further study of the IO system would be needed to develop binary communication protocols of your own, but if you're ok with plain text protocols - this should do just fine!<br /><br />Enjoy. <br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Michael Tuttle</div>
<div class='content'>
That looks really cool - nice and neat and simple. Thanks for the tip!</div>
</div>
<div class='comment'>
<div class='author'>Unknown</div>
<div class='content'>
The pipes and pipes network libraries are worth a look too. They let you work at a higher level of abstraction which is nice and haskell-ey. Here&#39;s a 2-line echo server using them:<br />https://gist.github.com/jhickner/5589907</div>
</div>
</div>
