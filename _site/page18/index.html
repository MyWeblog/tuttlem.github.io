<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Cogs and Levers &middot; A blog full of technical stuff
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A place for thoughts, ideas, tutorials and bookmarks. My brain can only hold so much, you know.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/tuttlem/tuttlem.github.io">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">Cogs and Levers</a>
            <small>A blog full of technical stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/01/17/uniform-initialization-with-c-11/">
        Uniform Initialization with C++11
      </a>
    </h1>

    <span class="post-date">17 Jan 2013</span>

    <h1>Uniform Initialization with C++11</h1>
<div class='post'>
Initialization of variables types has received a face lift with the new version of the C++ standard. Previously trying to initialize a populated list was impossible and you were left writing helper functions to transform array values into other container types, or worse you'd end up with code that looked like this.<br /><br /><script src="https://gist.github.com/4551170.js"></script> C++11 includes a feature called "Uniform Initialization" which aims to solve this problem. The above code now turns into this.<br /><br /><script src="https://gist.github.com/4551177.js"></script> Much better. This isn't where the&nbsp;convenience&nbsp;ends though. Take the following example. Because the "person" class defines a constructor taking in first_name, last_name and age we are able to use uniform initialization to setup these variables.<br /><script src="https://gist.github.com/4551245.js"></script> <br /><br />The same syntax works with any of the enumerated containers. Using the person class from above, we can make a map of employee records by doing the following.<br /><br /><script src="https://gist.github.com/4551296.js"></script> <br />You can see how this syntax makes the initialization process a much more pleasant experience in C++ now. That's all for this one.</div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/01/17/rvalue-references-in-c-11/">
        Rvalue references in C++11
      </a>
    </h1>

    <span class="post-date">17 Jan 2013</span>

    <h1>Rvalue references in C++11</h1>
<div class='post'>
This is the biggest change (shift anyway) in C++'s thinking with the new standard. This preview of Rvalue references probably isn't pitched at the novice and a bit of prior knowledge is assumed. You'll want to know the differences between an <a href="http://publib.boulder.ibm.com/infocenter/comphelp/v7v91/index.jsp?topic=%2Fcom.ibm.vacpp7a.doc%2Flanguage%2Fref%2Fclrc05lvalue.htm">Lvalue and an Rvalue</a>, you'll also want to understand how <a href="http://publib.boulder.ibm.com/infocenter/lnxpcomp/v8v101/index.jsp?topic=%2Fcom.ibm.xlcpp8l.doc%2Flanguage%2Fref%2Fcplr382.htm">temporary objects work</a>&nbsp;but most importantly why they're evil in some scenarios.<br /><br />With all of that information under our belt, I can see that the Rvalue reference came to fruition to resolve the copy problem. Returning a temporary object from a function that you'd use in your program would cause an expensive copy operation, now this is is resolved with move semantics.<br /><br />Rather than that expensive copy operation, the value that's returned is pilfered to the calling code and the temporary object is left empty, ergo a move occurs.<br /><br />An Rvalue reference is defined in code like so.<br /><br /><script src="https://gist.github.com/4555645.js"></script> The double ampersand (&amp;&amp;) tells us that it's an Rvalue reference. We can give our own classes the ability to "move" a value by introducing a move constructor and operator like so.<br /><script src="https://gist.github.com/4555709.js"></script> <br />The STL containers have all been optimised to use move syntax, so you'll pick up this copy-free functionality on the way.</div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/01/17/nullptr-in-c-11/">
        nullptr in C++11
      </a>
    </h1>

    <span class="post-date">17 Jan 2013</span>

    <h1>nullptr in C++11</h1>
<div class='post'>
It happened! It finally happened! "NULL" has a real identity within the language. Forever I'd used the notion of NULL in my C &amp; C++ to really mean "0" (zero) under the covers.<br /><br /><script src="https://gist.github.com/4552930.js"></script> <br />Of course, I'd never defined it myself. It was always done for me in one of the many include files drawn into my program. One of the problems with this particular define is for overloaded methods. If you were to pass "NULL" in its defined state above, you'd be guessing as to which overload is called.<br /><br /><br /><script src="https://gist.github.com/4552962.js"></script> <br />Well, now we have "nullptr" in C++11. "nullptr" is castable to any pointer type.<br /><br /><script src="https://gist.github.com/4552990.js"></script> The castability also covers off on boolean expressions, so the following if-trees will still work.<br /><br /><script src="https://gist.github.com/4552999.js"></script> <br />Finally, "nullptr" is of type "nullptr_t". If you're going to find it of use to you to guarantee that a null pointer is going to be passed into a method, you could type your method using the type "nullptr_t".<br /><br />Null now has a home.</div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/01/17/initial-investigations-of-c-11/">
        Initial investigations of C++11
      </a>
    </h1>

    <span class="post-date">17 Jan 2013</span>

    <h1>Initial investigations of C++11</h1>
<div class='post'>
I've written a lot of C and C++ code in my time but I have slipped as of late on keeping up with the published standards. Trying to remain abreast of too many things at once confuses me!<br /><div><br /></div><div>So, today's post I'll just be linking to all of the features that I've blogged about so far with C++11 that I hope should also give you a sniff to what's inside.</div><div><br /></div><div><ul><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/lambda-expressions-with-c11.html">Lambda Expressions in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/auto-and-decltype-in-c11.html">auto and decltype in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/defaulted-and-deleted-functions-in-c11.html">Defaulted and Deleted functions in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/uniform-initialization-with-c11.html">Uniform Initialization in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/enum-classes-in-c11.html">Enum Classes in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/nullptr-in-c11.html">nullptr in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/delegating-constructors-in-c11.html">Delegating Constructors in C++11</a></li><li><a href="http://cogsandlevers.blogspot.com.au/2013/01/rvalue-references-in-c11.html">Rvalue references in C++11</a></li></ul></div><div><br /></div><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/01/17/enum-classes-in-c-11/">
        Enum Classes in C++11
      </a>
    </h1>

    <span class="post-date">17 Jan 2013</span>

    <h1>Enum Classes in C++11</h1>
<div class='post'>
Enums in C/C++ have traditionally just been a pretty face for an integer value. That hasn't changed so much, but a new breed of enumeration has been added with C++11: enter the enum class.<br /><br />Enum classes have been introduced as a "strongly typed" enum. This gives you type safety in your enums so that you don't perform comparisons between enum types and if you do you'll need to explicitly define how the two should be compared.<br /><br />The other major benefit is improved scoping. Enum class values must always mention the enumeration that they belong to in order to be used.<br /><br />Here's an example of an enum class.<br /><br /><script src="https://gist.github.com/4551444.js"></script> Immediately the only difference that you'll see here is the addition of the word "class". You can still&nbsp;explicitly&nbsp;type and value your enumerations. Here's the same example above only written more verbosely.<br /><br /><script src="https://gist.github.com/4551454.js"></script> <br /><br />An example usage of these enum classes goes as follows.<br /><br /><script src="https://gist.github.com/4551472.js"></script> Well, there you have it. A brief tour of enum classes in C++11.</div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page19">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page17">Newer</a>
    
  
</div>
      </div>
    </div>

  </body>
</html>
