---
layout: post
title: Building a Tree
date: 2013-01-21
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>Following up from a <a href="http://cogsandlevers.blogspot.com.au/2013/01/basic-lexical-analysis-in-c.html">previous post</a>&nbsp;I had written on lexical analysis, I wanted to take you through the conversion of a list of scanned items into a tree that will become of more use once we start to compile to executable instructions.</div><div><br /></div><h3>Why a tree?</h3><div>When you look at a sequence of scanned items that come out of the lexer, its one-dimensional structure doesn't allow you to apply precedence easily. A tree structure lends itself very well to this problem exactly. See the following example. First, I'll give you an expression and then I'll (try) to put a tree together from said expression.</div><div><br /><pre class="brush:plain">As an expression:<br />(x &gt; 5) &amp;&amp; ((y &lt; 3) || (z &gt;= 6))<br /><br />As a tree:<br /><br />                 &amp;&amp;<br />               /    \<br />             /        \<br />            &gt;         ||<br />           / \       /  \<br />          x   5     &lt;    &gt;=<br />                   / \   / \<br />                  y   3 z  6 <br /></pre></div><div><br />I do appologise for my ASCII art, but you get the idea. We now have an order of&nbsp;precedence&nbsp;as we move from the root (or the top) of the tree down through the branches until we reach the leaf nodes which end up as our values that we're testing.<br /><br /><h3>Making the list into a tree</h3></div><div>We have a list of scanned items on one hand, we need to make it a tree. These (tree-related) problems lend themselves really well to recursive solutions, and you'll see this pop up quite a bit when working with tree structures. Here's how we define a node within the tree (which is actually how we'll refer to the tree overall).</div><div><br /><script src="https://gist.github.com/4583311.js"></script></div><div><br />Pretty easy and illustrative of the tree above. We have information "here" and we have further trees "left" and "right". The generation process is pretty straight forward. You need to keep in mind the following though:<br /><br /><ul><li>New scope (or a left paren) means we need to recurse a level deeper</li><li>End of scope (or a right paren) means we need to drop out to get back to a level above in the recursion stack</li><li>Any operator is just the value "here"</li></ul><div>Three simple rules all wrapped up in the crux of a switch statement here.</div><div><br /><script src="https://gist.github.com/4583314.js"></script></div><div><br /></div><div>This code is commented fairly well. It's a pretty straight forward concept anyway. From here you should have no trouble translating the expression tree which we've just generated into your own programs execution paradigms.</div><div><br />The source code that these articles are based upon is available in my <a href="https://github.com/tuttlem/">GitHub repository</a> in a project called <a href="https://github.com/tuttlem/Umpire">Umpire</a>.</div></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
