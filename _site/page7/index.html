<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Cogs and Levers &middot; A blog full of technical stuff
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A place for thoughts, ideas, tutorials and bookmarks. My brain can only hold so much, you know.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/tuttlem/tuttlem.github.io">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">Cogs and Levers</a>
            <small>A blog full of technical stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/20/gouraud-shaing-with-scan-line-polygons/">
        Gouraud Shaing with Scan Line Polygons
      </a>
    </h1>

    <span class="post-date">20 Nov 2013</span>

    <h1>Gouraud Shaing with Scan Line Polygons</h1>
<div class='post'>
<h3>Introduction</h3>In my <a href="http://cogsandlevers.blogspot.com.au/2013/11/scanline-based-filled-polygons.html">previous post</a>, we went through the basics of rasterising polygons on screen by use of horizontal lines. To sum up, we interpolated values along each edge of the polygon, collecting minimum and maximums for each y-axis instance.<br /><br />Today, we're going to define a colour value for each point on the polygon and interpolate the colours along each edge. This is the technique employed to draw polygons that are <a href="http://en.wikipedia.org/wiki/Gouraud_shading">Gouraud shaded</a>.<br /><br /><h3>The Code</h3>The structure of this is very similar to drawing a single colour block polygon. For a solid colour polygon, we interpolated the x values over the length of the y values. We'll now employ this same interpolation technique over the red, green, blue and alpha channels of each colour defined for each polygon point.<br /><br />Here's the scanline function.<br /><br /><br /><script src="https://gist.github.com/tuttlem/7561758.js"></script> <br />An immediate code restructure difference here from the first tutorial, is I'm now passing an actual point object through as opposed to each component of each point being a function parameter. This is just to clean up the interface of these functions.<br /><br />We're creating differentials not only for x now but also the r, g, b and a components. These will form the start and ending colours for each horizontal line that we'll draw. We still have extra interpolation to do once we're in the horizontal line draw function as well. Here it is.<br /><br /><br /><script src="https://gist.github.com/tuttlem/7561819.js"></script> <br />Again, more interpolation of colour components. This is what will give us a smooth shading effect over the polygon.<br /><br />Finally, the actual polygon function is a piece of cake. It just gets a little more complex as we have to send in colours for each point defined.<br /><br /><br /><script src="https://gist.github.com/tuttlem/7561874.js"></script> <br />Aside from the interface changing (just to clean it up a bit) and managing r, g, b and a components - this hasn't really changed from the block colour version. If you setup this polygon draw in a render loop, you should end up with something like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-CiuOyHrMVSo/UoyhbG4z5OI/AAAAAAAAAw4/AcYzDBUEhmA/s1600/Screen+Shot+2013-11-20+at+9.47.20+pm.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="156" src="http://1.bp.blogspot.com/-CiuOyHrMVSo/UoyhbG4z5OI/AAAAAAAAAw4/AcYzDBUEhmA/s320/Screen+Shot+2013-11-20+at+9.47.20+pm.png" width="320" /></a></div><br /><br /><br /><br />Smooth. <br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/19/scanline-based-filled-polygons/">
        Scanline based filled Polygons
      </a>
    </h1>

    <span class="post-date">19 Nov 2013</span>

    <h1>Scanline based filled Polygons</h1>
<div class='post'>
<h3>Introduction</h3>In a <a href="http://cogsandlevers.blogspot.com.au/2013/11/pixel-access-to-canvas-with-javascript.html">previous post</a> I laid down some foundation code to get access to the pixel buffer when in context of a HTML canvas. Good for those who have experience writing graphics code directly against the video buffer - it almost feels like you're writing to 0xA000 :-)<br /><br />Today's post will focus on drawing polygons to the screen using scan lines.<br /><br /><h3>Scan lines</h3>The whole idea here is that a polygon can be represented on screen as a series of horizontal lines. Take the following picture for example. You can see the red and blue horizontal lines making up the filling of the polygon.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-7VZcWuk1AkQ/UotS_qdPXrI/AAAAAAAAAwM/DlKjKBnH2lA/s1600/y.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://1.bp.blogspot.com/-7VZcWuk1AkQ/UotS_qdPXrI/AAAAAAAAAwM/DlKjKBnH2lA/s200/y.png" width="200" /></a></div><br />So, to define this all we do is take note of the minimum and maximum x values for every y-axis instance that there is a line on. We run through the array of values drawing horizontal lines at each instance, and then we have a polygon on screen - pretty easy.<br /><br /><h3>Code</h3>First of all, we'll define our drawing primitive for a horizontal line.<br /><br /><br /><script src="https://gist.github.com/tuttlem/7544385.js"></script> <br />We pass in the two x values for the line to go between, the y value for the line to sit on. To help with the offset calculation we also pass in the width "w" to correctly calculate the pitch. Finally the colour components and buffer to draw to are passed in. Setting this code up in a run loop, you end up with something like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-QMhBzwZnDUI/UotUjD3Cj4I/AAAAAAAAAwY/JxoFPAPDovE/s1600/Screen+Shot+2013-11-19+at+10.06.53+pm.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="222" src="http://2.bp.blogspot.com/-QMhBzwZnDUI/UotUjD3Cj4I/AAAAAAAAAwY/JxoFPAPDovE/s320/Screen+Shot+2013-11-19+at+10.06.53+pm.png" width="320" /></a></div>Yep, there's lots of horizontal lines.<br /><br />Referring to our horizontal line diagram above, we still need a way to walk the edges of the polygon so that we can get the minimum and maximum x values to start drawing. Because our basic unit is the pixel (considering we're rasterising to a pixelated display), we can easily calculate the gradient of the line that we need by:<br /><br /><pre>(change in x) / (change in y)<br /><br />For a line given by (x1, y1) - (x2, y2), this translates into:<br /><br />(x2 - x1) / (y2 - y1)<br /></pre><br />Taken out of context of maths, this just says to us: we want to walk from x1 to x2 using (y2 - y1) steps.<br /><br /><br /><script src="https://gist.github.com/tuttlem/7544449.js"></script> <br />From the code above, we treat x1, y1 as the starting point and x2, y2 as the ending point. Our for-loop is biased in the positive direction, so it's important for us to flip the values if they come in inverted.<br /><br />The edges array that's passed in is prepared by the caller of this function. It's initialized with very unreasonable minimum and maximum values. We than run over all 4 polygon edges<br /><br /><pre>(x1, y1) -&gt; (x2, y2)<br /><br />(x2, y2) -&gt; (x3, y3)<br /><br />(x3, y3) -&gt; (x4, y4)<br /><br />(x4, y4) -&gt; (x1, y1)<br /><br /></pre><br />At the end of this process, "edges" is full of minimum/maximum values ready for drawing. Here's the code for the polygon.<br /><br /><br /><script src="https://gist.github.com/tuttlem/7544554.js"></script> <br />This really is just putting all the pieces together. The building of the edges array is important - as is using the y co-ordinate (adjusted back to zero by proxy of the minimum y value) as an array index.<br /><br />Once you've got this setup in a random position &amp; colour loop, you'll end up with something like this:<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-D2yDU9iTdc0/UotZcoZ2jtI/AAAAAAAAAwo/QCW0Qi8rhSQ/s1600/Screen+Shot+2013-11-19+at+10.27.57+pm.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-D2yDU9iTdc0/UotZcoZ2jtI/AAAAAAAAAwo/QCW0Qi8rhSQ/s320/Screen+Shot+2013-11-19+at+10.27.57+pm.png" width="320" /></a></div><br />mmmm... Tasty.<br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/19/purging-all-of-the-data-within-solr/">
        Purging all of the data within Solr
      </a>
    </h1>

    <span class="post-date">19 Nov 2013</span>

    <h1>Purging all of the data within Solr</h1>
<div class='post'>
During the test phases of getting your software setup, you'll find it useful to completely toast what ever data you've already indexed to start fresh.<br /><br />This is as simple as issuing a delete query with open criteria (*.*). The full query should translate to &lt;delete&gt;&lt;query&gt;*.*&lt;/query&gt;&lt;/delete&gt;.<br /><br />As a URL it'll look like this:<br /><br /><pre class="brush: plain">http://[your solr server]:8080/solr/update?<br />stream.body=%3Cdelete%3E%3Cquery%3E*:*%3C/query%3E%3C/delete%3E&amp;commit=true</pre><br />Note that there is a commit at the end of this URL which will perform the delete and commit the result all in the one invocation.<br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/18/pixel-access-to-the-canvas-with-javascript/">
        Pixel Access to the Canvas with Javascript
      </a>
    </h1>

    <span class="post-date">18 Nov 2013</span>

    <h1>Pixel Access to the Canvas with Javascript</h1>
<div class='post'>
<h3>Introduction</h3>Gaining pixel-level access using the HTML canvas opens up some possibilities for some frame-buffer style rasterisation. Today's post will focus on the code required to get you access to this array.<br /><br />Here's the code on how to get started:<br /><br /><script src="https://gist.github.com/tuttlem/7526425.js"></script> <br /><br />First of all, we programmatically create our canvas object using <a href="http://www.w3schools.com/jsref/met_document_createelement.asp">document.createElement</a>. Using the inner dimensions of the window, we can then set the canvas' size. Of course this can be custom set to the dimensions you require - I just like to take over the whole window!<br /><br />Using the <a href="http://www.w3schools.com/tags/ref_canvas.asp">canvas object</a>, we then pull out the drawing context with getContext. The next part, using <a href="http://www.w3schools.com/tags/canvas_createimagedata.asp">createImageData</a> we then get a reference to the frame-buffer to draw to. This gives us read/write access to the canvas through an array.<br /><br />Finally, we'll take note of the width and height (this will come in handy later) and then pop the canvas onto the page.<br /><br /><h3>Frame-buffer structure</h3>So, I say "frame-buffer" - but it's just an array. It's quite nicely laid out such that pixels start at every 4 elements within the array. The first element being the red component, second is green, third is blue and the fourth is the alpha.<br /><br />Calculating an offset into the array is a piece of cake. For example, take the following piece of code which will allow you to set a single pixel on the frame-buffer.<br /><br /><script src="https://gist.github.com/tuttlem/7526558.js"></script> <br /><br />The main part to focus on here is the calculation of the offset. Above, I said it was important to take note of the dimensions - we're only using the width here. This is pretty straight forward calculation of an offset within a linear data segment with Cartesian co-ordinates.<br /><br /><h3>Flip out!</h3>Now that we've drawn all of the data to the image buffer (frame-buffer), we need a way to get it back onto our canvas. This is simply done using <a href="http://www.w3schools.com/tags/canvas_putimagedata.asp">putImageData</a>.<br /><br /><script src="https://gist.github.com/tuttlem/7526631.js"></script> <br /><br />That's it for now. </div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>SEO Dewintec</div>
<div class='content'>
This comment has been removed by a blog administrator.</div>
</div>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/18/mpt-statusd-detected-non-optimal-raid-status/">
        Mpt Statusd Detected Non Optimal Raid Status
      </a>
    </h1>

    <span class="post-date">18 Nov 2013</span>

    <h1>Mpt Statusd Detected Non Optimal Raid Status</h1>
<div class='post'>
After installing Debian within a few VMWare virtual machines, I keep getting a rather annoying and persistent "mpt-statusd: detected non-optimal RAID status" spamming out my unix mail box as well as /var/log/messages.<br /><br />Simplest solution that I've come across is to just . . .<br /><br /><br /><pre class="brush: shell">$ sudo apt-get remove mpt-status</pre><br /><br />Yup! That's it.</div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page8">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page6">Newer</a>
    
  
</div>
      </div>
    </div>

  </body>
</html>
