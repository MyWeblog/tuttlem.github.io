---
layout: post
title: Generic value interpolation
date: 2012-12-12
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3>The core of animation in software (not&nbsp;necessarily&nbsp;graphical) is movement. That movement is between known points to achieve and overall effect. Such well-known movements might be a human moving their legs&nbsp;alternatively&nbsp;so that they can <b>walk </b>or a sound constantly moving from low to high to make a <b>siren</b>&nbsp;or moving your mouse cursor <b>automatically.</b>&nbsp;All of these things share the same premise. An attribute of the object needs to have its position interpolated from a starting point to an ending point over a period of time.<br /><br />Some of these interpolations repeat, some do not.<br /><br />Today's post is about interpolating values between two points, but it's about doing it with any type and with any interpolation scheme. Let's break these parts down.<br /><br /><h3>Doing it with any type</h3><div>The idea here is that anything (within reason) can be interpolated. In real C/C++ terms, I mean short, int, long, float, double, char, etc. A little more interestingly when dealing with spatial objects, we could define our own&nbsp;Cartesian&nbsp;co-ordinate object - give this object X and Y attributes and then interpolate this co-ordinate between two points.<br /><br /></div><h3>Interpolation schemes + some math</h3><div>It's the small details that matter. Linear interpolation is the simplest form of interpolation leaning on the whole "the shortest distance between two points is a straight line". Linear interpolation will take its sequence values for progressing the object through its interpolation life using:</div><blockquote class="tr_bq"><i>y = c + mx</i></blockquote>Which looks dangerously close to the standard formula you would use to draw a straight line. In this case <i style="font-weight: bold;">c </i>would be our starting point, <i style="font-weight: bold;">m</i>&nbsp;would be the distance (or length) between the start and end points and <i style="font-weight: bold;">x </i>defines how far along our interpolation progression we are taking the form in range of 0.0 up to 1.0.<br /><br />Another interesting scheme is trigonometric in nature. Using a soft curve to get between two points can be a softer approach. Trigonometric interpolation will take its sequence values for progressing the object through its interpolation life using:<br /><blockquote class="tr_bq"><i>y = c + (sin(x * (PI / 2)) * m)</i></blockquote>Again, we have alike named variables in that <i style="font-weight: bold;">c </i>is our start point, <i style="font-weight: bold;">x </i>is our progress through the interpolated progression and <i style="font-weight: bold;">m</i>&nbsp;is the distance. Notice how our progress, <i style="font-weight: bold;">x </i>is multiplied by <i style="font-weight: bold;">(PI / 2)</i>&nbsp;only talking us 1 quarter through the progress of the curve. This is simply because we're at 0% progress at 0 degress and 100% at 90 degrees.<br /><br /><h3>Show me some code</h3><div>First off, we have a base "tweener" object that will manage all of the mundane tasks that this interpolater will need to undergo in order to&nbsp;realize&nbsp;these tweened-values. You'll notice that it is in fact a templated C++ class .</div><div><br /><script src="https://gist.github.com/4262914.js"></script></div><div><br /></div><div><br /></div><div>Ignore the timer class for now. It's there just so we can make the interpolations happen with respect to time. We move ourselves along the interpolation progression just with some simple math with regards to time. To be a little more polite about things, we detect when we're at the start and just send the start value and detect when we're at the end and just send the end value - rather than calculating this over and over.<br /><br /><script src="https://gist.github.com/4262934.js"></script></div><div><br /></div><div>The custom implementations for getting actual values (from types of interpolation) are as simple as this:<br /><br /><script src="https://gist.github.com/4262954.js"></script> <br /><br />So you can see that these custom implementations marry very closely to the&nbsp;formula&nbsp;we specified above. I think that this design documents the implementer's intention very clearly by not having to worry about the progression code.<br /><br />The choice of using C++ templates also allows future implementations to target specific types. Whilst the implementations given in this article will work well for scalar values, they won't translate very well to complex class types that don't correctly implement operator overloading with mathematical correctness in mind. That being said, if the scope of implementation is beyond what the generic base provides, it's only a matter of specifying the specific type when implementing your own <i style="font-weight: bold;">value_internal</i>&nbsp;method.<br /><br />Enjoy.<br /><br /><h3>A few tweeners more</h3></div><div>Just playing around with the code set that I have here, I've been able to make logarithmic and parabolic tweeners relatively easy. It would be great to be able to control the co-effecients in the parabolic formula, but for the time being it's a quadratic class:</div><blockquote class="tr_bq"><i>y = x<sup>2</sup> + c</i></blockquote><br /><script src="https://gist.github.com/4264400.js"></script> <br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>
