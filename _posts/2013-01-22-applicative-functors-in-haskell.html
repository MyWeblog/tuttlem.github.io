---
layout: post
title: Applicative Functors in Haskell
date: 2013-01-22
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>As a follow up to my <a href="http://cogsandlevers.blogspot.com.au/2013/01/functors-in-haskell.html">previous post</a>&nbsp;on Functors, it's a natural progression for me to do a post on the more advanced version, the Applicative Functor. In a normal functor, you'll map a function over a functor and applicative functor is a reverse view of this where it'll allow you to map many functor values over a single function.</div><div><br /></div><h3>What is an Applicative Functor?</h3><div>At the code level, an Applicative Functor is any type that is in instance of the <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">Applicative</a>&nbsp;typeclass. At a concept level, the Applicative Functor has not only the values in "a context" but also the function that we'll apply is in a context. This differs from just a normal Functor (<a href="http://cogsandlevers.blogspot.com.au/2013/01/functors-in-haskell.html">read more here</a>) where it's only the value that's wrapped in a context.&nbsp;</div><div><br /></div><div>An <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">Applicative Functor</a>&nbsp;has 2 functions that require implementation. <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:pure">pure</a>&nbsp;and <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a>. This typeclass and functions are defined as follows.</div><div><br /><script src="https://gist.github.com/4589744.js"></script></div><div><br />The definition for&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:pure">pure</a>&nbsp;on Hoogle suggests that it will<br /><blockquote class="tr_bq"><i>Lift a value</i></blockquote>"Lifting" is very well described in articles all over the web. Here's the <a href="http://www.haskell.org/haskellwiki/Lifting">Haskell Wiki's article</a>&nbsp;on Lifting.&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:pure">pure</a>&nbsp;takes in a value and returns an applicative value around that value. It's actually quite a simple definition when you read it.<br /><br />The other function defined here is&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a>. &nbsp;The definition for&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a>&nbsp;on Hoolgle suggests that it will perform<br /><blockquote class="tr_bq"><i>Sequential application</i></blockquote>The definition of sequential application here can be expanded such that&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a>&nbsp;takes a function <b>(a -&gt; b)&nbsp;</b>wrapped up in a functor&nbsp;<b>f</b> and another functor value <b>f a</b>. It'll extract the function from the first parameter <b>(a -&gt; b)</b>, map it over the functor value <b>f a</b>&nbsp;to produce a result <b>f b</b>.<br /><br />The concept is very similar to what we've seen before in mapping scenarios, it's just that we "map" with different "things". Today we're mapping with functor values over a function.<br /><br /><h3>Pure</h3>Here's some examples of&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:pure">pure</a>&nbsp;in action. You'll see that when we're casting to a type, we receive the appropriate value back<br /><br /><pre class="brush:plain">&gt; pure "Hey" :: Maybe String<br />Just "Hey"<br /><br />&gt; pure "Should be in a List" :: [String]<br />["Should be in a List"]<br /></pre><br />You can see here that the value is "lifted" by&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:pure">pure</a>&nbsp;into the container (in this case either a Maybe or a List).<br /><br /><h3>&lt;*&gt;</h3>For the next set of examples, I'll show you some usages of &nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a>. You'll need to keep in the front of your mind that all functions on the left hand side are applied to all values on the right hand side, so we end up with a&nbsp;Cartesian&nbsp;effect.<br /><br /><pre class="brush:plain">&gt; [sin, cos, tan] &lt;*&gt; [pi, pi, pi]<br />[1.2246467991473532e-16,1.2246467991473532e-16,1.2246467991473532e-16,-1.0,-1.0,-1.0,-1.2246467991473532e-16,-1.2246467991473532e-16,-1.2246467991473532e-16]<br /></pre><br />The&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:-60--42--62-">&lt;*&gt;</a>&nbsp;function is left associable, so when you start chaining calls together it's the leftmost that is evaluated first.<br /><br /><pre class="brush:plain">&gt; [(+),(*)] &lt;*&gt; [1,2] &lt;*&gt; [3,4]<br />[4,5,5,6,3,4,6,8]<br /><br />(which is really)<br />[1+3,1+4,2+3,2+4,1*3,1*4,2*3,2*4]</pre><div><br /><h3>Applicative Style</h3>You can see how using this "applicative style" in code can often be swapped 1-for-1 with list comprehensions as you achieve the same permuted or&nbsp;Cartesian&nbsp;effect. Take this for example.<br /><br /><pre class="brush:plain">&gt; [salutation ++ name | salutation &lt;- ["Hello ", "Goodbye ", "Yo! "], name &lt;- ["John", "Mary", "Anne"]]<br />["Hello John","Hello Mary","Hello Anne","Goodbye John","Goodbye Mary","Goodbye Anne","Yo! John","Yo! Mary","Yo! Anne"]<br /><br />&gt; (++) &lt;$&gt; ["Hello ", "GoodBye ", "Yo! "] &lt;*&gt; ["John", "Mary", "Anne"]<br />["Hello John","Hello Mary","Hello Anne","Goodbye John","Goodbye Mary","Goodbye Anne","Yo! John","Yo! Mary","Yo! Anne"]<br /></pre><br />You can see that when dealing with lists, the following is true:<br /><br /><pre class="brush:plain">pure f &lt;*&gt; xs == fmap f xs</pre><br />In this context, "pure f" is putting f into a list. "[f] &lt;*&gt; xs" just applies each function in the left list to the right.<br /><br />Another implementation of the Applicative Functor that doesn't follow the same notion of a List is its use with IO. The idea of the applicative functor still holds, but when dealing with IO its the actions that are operated on. This can be thought of in the same way as sequencing and mapping in one.<br /><br /><h3>ZipList</h3>Another type that is an instance of&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:Applicative">Applicative</a>&nbsp;is the <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:ZipList">ZipList</a>. The&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:ZipList">ZipList</a>&nbsp;type is defined as follows.<br /><br /><script src="https://gist.github.com/4591634.js"></script> <br />When we use applicative style on a normal list, we end up with a Cartesian product of the two lists involved. A&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#v:ZipList">ZipList</a>&nbsp;differs here by operating on indicies in either list that are the same. Index [0] on the left gets applied to Index [0] on the right. Index [1] on the left gets applied to Index [1] on the right, and so on.<br /><br /><h3>Applicative Functor Laws</h3><div>Finally, there are a few laws that applicative functors must abide by, they are as follows.</div><div><div><ul><li><pre>pure id &lt;*&gt; v = v</pre></li><li><pre>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</pre></li><li><pre>pure f &lt;*&gt; pure x = pure (f x)</pre></li><li><pre>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</pre></li></ul></div></div><br /><h3>Applying applicative functors for yourself</h3><div>This has been a very difficult topic that I've burnt some time on as late. There are plenty of examples of how this knowledge has been applied for a List or Maybe, but I've struggled to apply this to a type of my own. So far though, I've come across <a href="http://en.wikibooks.org/wiki/Haskell/Applicative_Functors">this article on Applicative Functors</a> on the Hakell Wiki and most notably this sentence:</div><blockquote class="tr_bq">Anytime you feel the need to define different higher order functions to accommodate for function-arguments with a different number of arguments, think about how defining a proper instance of Applicative can make your life easier.</blockquote>That to me makes sense. So, if you have a function that operates on a particular type and you'd like to apply that function to "n" arguments - you'd normally create an fmap clone that would cater for that many arguments. Using an applicative functor, the re-creation of the fmap instance goes away as your higher-order function can expect any number of arguments.<br /><br />Because of this, the following is true.<br /><br /><script src="https://gist.github.com/4601255.js"></script> That's it for today's post. I hope to update this post with some more examples and information as I discover it!</div></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
