---
layout: post
title: List comprehension in Haskell
date: 2012-12-27
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>Generating and operating on lists of data in languages is an essential tool when doing even the most basic of processing. List comprehension is just this process. It's prevalent in most of today's languages and today I want to post about <a href="http://www.haskell.org/haskellwiki/List_comprehension">this process in Haskell</a>.</div><div><br /></div><h3>A numeric example</h3><div>Working with numeric data is probably the easiest of examples to help you grasp this concept. Let's start by using a list comprehension to generate a list of numbers 1-through-5.<br /><br /></div><pre>[x | x &lt;- [1..5]]</pre><br />This will return a list looking like [1, 2, 3, 4, 5]. Analysing what we've just written here, we can see that what we want to return is on the left hand side of the pipe "|" symbol, how we want to generate each value sits on the right hand side of the pipe symbol. This expression is wrapped in square braces because we want a list!<br /><br />We can change this ever so slightly to only give us back odd numbers like so:<br /><br /><pre></pre><pre></pre><pre>[x | x &lt;- [1..5], odd x]</pre><br />You can see that we've just concatenated another piece of criteria to the right hand side of the expression specifying that we only want odd numbers. We then end up with a list looking like [1, 3, 5]. These are still very simple examples, but we can do some very powerful things with these expressions.<br /><br />Take the following for example.<br /><br /><pre>[x * y | x &lt;- [1..5], y &lt;- [1..5]]</pre><br />Looking at the left-hand side you can see that we want the multiple of x and y. On the right-hand side you can see that both x and y iterate 1-through-5, so we end up with the following:<br /><br /><pre>[1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,5,10,15,20,25]</pre><br />Now we're getting somewhere.<br /><h3>Not so numeric, but close</h3><div>When I first saw this technique employed, I'd immediately seen its use in many places. The first place that I decided to put it though was <a href="http://cogsandlevers.blogspot.com.au/2012/11/i-need-to-crawl-before-i-can-walk-so.html">generating a deck of card</a>. This link is to an Uno implementation that I tried out in Haskell, and if you're&nbsp;familiar&nbsp;with the game, you have colour cards and you have wild cards, so I could represent a deck with the two following expressions:</div><div><br /></div><pre>[Card v (Just c) | v &lt;- [Naught .. DrawTwo], c &lt;- [Red .. Yellow]]<br />[Card v Nothing | v &lt;- [Wild .. WildDrawFour]]</pre><div><br /></div><div>These two expressions gave me a deck of cards ready to shuffle! No "for-loops" here ma!<br /><br /><h3>Strings are just arrays of chars!</h3></div><div>Correct, they are. So it should be no surprise that this statement:<br /><br /><pre>[a | a &lt;- ['a'..'z']</pre><br /></div>generates a string that looks like this:<br /><br /><pre>"abcdefghijklmnopqrstuvwxyz"</pre><br />Pretty easy/obvious.<br /><br />The complexities of list processing and generation can be greatly simplified in your code if you can master the list comprehension.<br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>
