---
layout: post
title: Windows Development with MASM32 (part 4)
date: 2012-11-28
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>Welcome to the fourth instalment in this windows development series. Just to re-cap the story so far, we've:</div><div><ul><li><a href="http://cogsandlevers.blogspot.com.au/2012/11/windows-development-with-masm32-part-1.html">Displayed a message box to the screen</a> in part 1</li><li><a href="http://cogsandlevers.blogspot.com.au/2012/11/windows-development-with-masm32-part-2.html">Setup a message pump</a> in part 2</li><li><a href="http://cogsandlevers.blogspot.com.au/2012/11/windows-development-with-masm32-part-3.html">Created a basic window</a> in part 3</li></ul><div>It's time to try something a little fun and little out of the tutorial mould that you'd be expecting at part 4. Today, lets create a window and setup a double buffer to provide flicker-free animation into our windows applications.</div></div><div><br /></div><div>This is going to be of great use if we want to do our own custom drawing without employing DirectX or OpenGL. Most of all, it'll be a laugh getting there.</div><h3>Double buffer theory, GDI style</h3><div>In a generic sense, we manage a block of memory (away from the visible video memory) that has the same characteristics (width, height and depth) as the screen we're presenting. We perform all of our drawing within this off-screen memory buffer and then "flip" it over onto the presenting video memory when we're ready to show it.</div><div><br /></div><div>In GDI land, this procedure is split between a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">HDC</a>&nbsp;and a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">HBITMAP</a>. A&nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">HDC</a>&nbsp;is obtained so that we have an access context into allocated memory. This is also what we'll use when we go to draw something. Where it's stored is in the bitmap.&nbsp;A&nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">HBITMAP</a>&nbsp;is obtained so that we can match what is being presented to the user in video memory. Windows does a good job of copying these characteristics when we call <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd183488(v=vs.85).aspx">CreateCompatibleBitmap</a>.</div><h3>Supporting the back-buffer</h3><div>So, we need a couple of functions in order to keep the backbuffer happy when the window changes. We need to react when Windows tells us something about the window. In this scenario, we're going to be very interested in the resize message (<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms632646(v=vs.85).aspx">WM_SIZE</a>). We need to teardown any already setup back buffer, create a new one of adequate size and continue on.</div><div><br /></div><div>Let's take a look at the code that's will create and re-create our back-buffer when requested.</div><div><br /><script src="https://gist.github.com/4161317.js?file=gistfile1.asm"></script></div><div><br /></div><div><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms633503(v=vs.85).aspx">GetClientRect</a> fills out a <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">RECT</a> structure for us with the client dimensions of the window. This is perfect to give us the dimensions for the back buffer. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd144871(v=vs.85).aspx">GetDC</a> obtains a device context directly on the window for us and we use this&nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">HDC</a>&nbsp;in order to create an in-memory representation using <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd183489(v=vs.85).aspx">CreateCompatibleDC</a>. Now that we know what we'll end up drawing to, we just need a buffer off-screen that will hold our intermediate frame. We do this by using&nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd183488(v=vs.85).aspx">CreateCompatibleBitmap</a>.<br /><br />You'll see a reference to the teardown for the backbuffer in the creation procedure. It's all about safety making sure we're un allocated before trying again. Here's that teardown.<br /><br /><script src="https://gist.github.com/4161329.js?file=gistfile1.asm"></script> <br /><br /></div><div>Tearing down is really just use of <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd183539(v=vs.85).aspx">DeleteObject</a> and <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd162920(v=vs.85).aspx">ReleaseDC</a> calls. This is fairly straight forward.<br /><br />Finally, we need to be able to send the back buffer to the front (visible) buffer. This flip method using GDI calls is how we accomplish that.<br /><br /><script src="https://gist.github.com/4161348.js?file=gistfile1.asm"></script> <br />A point to note here is the use of <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd183370(v=vs.85).aspx">BitBlt</a>. We need a way to quickly copy everything on the back buffer to everything on the front buffer. <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/dd183370(v=vs.85).aspx">BitBlt</a> is purpose built to work on copying bitmaps between&nbsp;<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/aa383751(v=vs.85).aspx">HDC</a>'s so this is the natural choice.<br /><h3>Not a normal message pump</h3></div><div>The type of application has changed. We're now targeting an animating, constantly re-drawn application that needs a new style of message pump. The last type of message pump was very passive, only doing something when required. This new one is very active - peeking the message stack using <a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms644943(v=vs.85).aspx">PeekMessage</a>&nbsp;to determine if messages need to be processed, otherwise re-drawing the application.</div><div><br /></div><div>Here's the message pump for the application.</div><div><br /><script src="https://gist.github.com/4161383.js?file=gistfile1.asm"></script></div><div><br /></div><div><br /></div><div>Finally, we have the window procedure. This is what will co-ordinate the destruction and re-creation of the back buffer when catastrophic changes occur to the visual appearance of the application.<br /><br /><script src="https://gist.github.com/4161428.js?file=gistfile1.asm"></script> <br />That's about it for the double-buffer side of things. The rest of the application itself does have some trickery behind drawing random shapes, but I'll leave the random number generator for a later post.<br /><br />Get double buffering!</div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
