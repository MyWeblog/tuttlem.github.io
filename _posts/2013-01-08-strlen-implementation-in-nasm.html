---
layout: post
title: strlen() implementation in NASM
date: 2013-01-08
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>Seeing so many "Hello, world" concepts for getting up an running in Assembly has annoyed me a little bit. I see people using the "$ - msg" macro to calculate the length of their string at assemble time.</div><div><br /></div><div>In today's post, I'll show you how to measure the length of your string at runtime so you'll be able to provide the <a href="http://en.wikipedia.org/wiki/Write_(system_call)">write</a>&nbsp;syscall's third parameter a little more flexibly.&nbsp;</div><div><br /></div><h3>The logic</h3><div>The logic behind this procedure is dead-simple. Test the current byte for being null, if it is get out now if its not keep counting! Here's how the code looks.</div><div><br /><script src="https://gist.github.com/4478792.js"></script></div><div>This is just straight-forward memory testing, no great advancements in computer science here! The function expects that the string that requires testing will be in the rdi register.<br /><br />To actually use this function in your application though, you'll need to transport the result (which sits in rax by the time the function has completed execution) into the register that write expects its length parameter. On a debian linux system, the length is expected in rdx which there is an example of <a href="http://cogsandlevers.blogspot.com.au/2012/11/hello-64bit-assembly.html">here</a>. OSX's ABI is slightly different but confusingly expects the length in the same register. You can read up on that <a href="http://cogsandlevers.blogspot.com.au/2013/01/assembly-on-osx.html">here</a>.<br /><br />Here's how you use your new strlen function (in the Debian scenario).<br /><br /><script src="https://gist.github.com/4478850.js"></script> So you can see that this is quite straight forward. We setup rdx before we setup the rest of the registers. We could have done this the other way around - to be on the safe side, I've done it this way as you never know what registers get mowed over in people's functions.<br /><br />I tried to help this also in the _strlen implementation by saving the only work register that I use (rcx).<br /><br />Anyway, that's how you measure your string.<br /><br /><h3>A more optimal way?</h3></div><div>After completing this article, I'd thought about the "brute-forcish" way that I'd crunched out the numbers to derive a string's length and thought to myself, what if I could just scan the string of bytes - find the null character and subtract this found index from the original starting point. Mathematically I would have calculated the distance in bytes between the start of the string and the NULL character, ergo the string length.</div><div><br /></div><div>So, I've written a new string length implementation that does just this and here it is.</div><div><br /><script src="https://gist.github.com/4480719.js"></script></div><div><br />It may look longer than the first implementation however this second implementation uses <a href="http://courses.engr.illinois.edu/ece390/archive/spr2002/books/labmanual/inst-ref-scasb.html">SCASB</a>&nbsp;which will be heaps more optimal than my hand-rolled loop.<br /><br />Enjoy.</div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
