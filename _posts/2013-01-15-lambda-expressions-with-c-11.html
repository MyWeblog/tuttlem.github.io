---
layout: post
title: Lambda Expressions with C++11
date: 2013-01-15
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>A whole raft of goodness has been delivered with the most recent C++ standard, <a href="http://en.wikipedia.org/wiki/C%2B%2B11">C++11</a>. One of these features is the inclusion of lambda expressions. Today's post will take you through the basic syntax for lambdas in C++.</div><div><br /></div><h3>Basic Assignment</h3><div>You can assign a lambda to a variable quite simply with the following syntax.</div><div><br /><script src="https://gist.github.com/4538150.js"></script></div><div><br />I agree that this is a pretty ass-about-face way of printing "Hello, World" to the screen - but it's done through C++11's lambda syntax.<br /><br />Passing variables into a lambda expression and getting return values is quite trivial also.<br /><br /><script src="https://gist.github.com/4538172.js"></script> <br />You can nest lambdas pretty easily also. Heres is a multiply-then-divide example where the division operation is the nested operation. Multiplication occurs at the top-level lambda.<br /><br /><script src="https://gist.github.com/4538211.js"></script> <br />This syntax also allows you to define higher-order functions, so that you can return function object back to the caller for later use. Here, I've made a multiplier factory. You give it one side of the multiplication and it'll hand you back a function that will multiply by that number.<br /><br /><script src="https://gist.github.com/4538232.js"></script> <br />We've done something a little bit different here. You can see that we've used a term inside the square brackets for the returned function. C++ having a major focus on performance gives the developer as much flexibility as possible when handling values. The information specified within the square braces tells the lambda closure how to handle variables referenced within.<br /><br /><h3>Handling outside state within a lambda</h3></div><div>The developer describes to the lambda how she wants variables captured by making specifications within the square brackets. Some examples of what you might see look like this.</div><div><br /><table><tbody><tr><td><b>Specification</b></td><td><b>Meaning</b></td></tr><tr><td>[]</td><td>Don't capture anything</td></tr><tr><td>[&amp;]</td><td>Capture any variable by reference</td></tr><tr><td>[=]</td><td>Capture any variable used making a copy of it</td></tr><tr><td>[=, &amp;x]</td><td>Capture any variable used making a copy of it except for x. Capture x by reference.</td></tr><tr><td>[y]</td><td>Capture y by making a copy but nothing else.</td></tr><tr><td>[this]</td><td>Capture the enclosing class' pointer</td></tr></tbody></table></div><div><br /></div><div>So, we can be quite specific in telling the compiler how we want referenced variables handled within our lambda closure.<br /><br />Finally, I want to present some code on using lambdas with existing constructs. In this example, I'll reduce a list of integers by accumulating them into a variable referenced outside of a closure.<br /><br /><script src="https://gist.github.com/4538430.js"></script> <br />You can see that is is quite a fluent style for writing lambdas.<br /><br />This post only scratches the surface. Applying these in a real project is going to be key to discovering the depths of lambdas, but they're alive and well in C++(11) land, that's for sure.</div><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>nick black</div>
<div class='content'>
Great post, thanks! I think there might have been more difference between C++11 and C++03 than there was C++03 and C99.</div>
</div>
</div>
