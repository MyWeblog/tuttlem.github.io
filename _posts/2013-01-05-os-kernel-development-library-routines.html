---
layout: post
title: OS Kernel Development: Library Routines
date: 2013-01-05
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>In the <a href="http://cogsandlevers.blogspot.com.au/2013/01/os-kernel-development-bootloader.html">previous post</a> to this series, we implemented a boot loader that would integrate with the multi-boot standard to get your kernel going (in first gear). It's time to change gears and make our life a little easier by implementing some library routines that we'll use a lot of.</div><div><br /></div><h3>What routines will we need?</h3><div>By keeping the scope minimal we won't overwhelm ourselves and just leave this project in a steaming heap in the corner. I think if we can get the following accomplished, we'll be in a really good place to start with.</div><div><ul><li>Port communication I/O</li><li>Basic console handling</li></ul><div>There's still a mountain of work for us in the library arena. But if we can get these two knocked off, we'll at least be able to get our kernel to say something when it boots up rather than that rather unfriendly blank screen.</div></div><div><br /></div><h3>Ports</h3><div>We set different pieces of hardware state on our computer by pushing data out to ports. We also find out state information about our computer by drawing data from these ports. In our particular case, we want to know where the cursor is on screen we also want to be able to move the cursor about. These things don't just happen by themselves you know, there is underlying magic with ports to give the console a human feel.</div><div><br /></div><div>The following code will allow us to read in a byte (8 bits), read in a short (16 bits) and write a byte to and from the ports.</div><div><br /><script src="https://gist.github.com/4461056.js"></script></div><div><br /></div><div><br /></div><div>If we wanted to, we could have implemented these directly in an assembly module. These do assume that a particular architecture has been chosen for your kernel, so the portability of this code is minimal.<br /><br /><h3>Console</h3></div><div>Now that we have a few routines that will allow us to do some port communication, we can put these to work by doing our console simulation.</div><div><br /></div><div>The console itself is represented on screen as a cartesian plane but it's certainly not this way in memory. In memory the console is a linear block of memory that has a pair of bytes per cell on the screen. One byte being for the actual character in that cell and the other byte to decorate that cell (background &amp; foreground colours). This memory buffer is located at segment 0xB800 (of course, again, on an intel architecture).</div><div><br /></div><div>The block of most interest when putting a character on screen looks like this.</div><div><br /><script src="https://gist.github.com/4461077.js"></script></div><div><br /></div><div>You can see that we're handling cases for backspace, tab, line feed &amp; carriage return and of course any actual character that we want printed. Most of the others are just routine cursor maintenance. The last segment in the if tree, you can see that location is calculated and then the char is spat into the cell.<br /><br />Writing a string to the console makes great use of this char writer.<br /><br />The full source to these routines can be found in my GitHub repository for Phoenix, <a href="https://github.com/tuttlem/phoenix/">here</a>.</div><div><br /></div><div><br /></div><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
