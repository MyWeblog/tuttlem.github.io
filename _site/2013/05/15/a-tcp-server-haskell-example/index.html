<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      A TCP Server Haskell Example &middot; Cogs and Levers
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A place for thoughts, ideas, tutorials and bookmarks. My brain can only hold so much, you know.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/tuttlem/tuttlem.github.io">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">Cogs and Levers</a>
            <small>A blog full of technical stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">A TCP Server Haskell Example</h1>
  <span class="post-date">15 May 2013</span>
  <h1>A TCP Server Haskell Example</h1>
<div class='post'>
<h3>Introduction</h3>In today's post, I'll demonstrate (and explain) how to put together a very simple TCP server in Haskell. The most simple example that I can think of, that will still leave you with enough skeleton to get up and running yourself is an echo server.<br /><br /><h3>The Functional Specification</h3>An Echo server. The drab, beige, sensible-older-brother in the server world. We'll accept incoming connections on a port and recite (echo) any data sent to us by the client. Simple.<br /><h3>Design</h3>Using the network, concurrency and system modules in Haskell, you're actually allowed a pretty simple and fluid design. Of course, you can make this as "one-liner" as you'd like, but for demonstration purposes today I'll break the server over a few parts:<br /><ul><li>Main program</li><li>Socket handler</li><li>Echo implementation</li></ul>The main program will take care of getting us out of first gear. It'll setup a listening socket (or server socket) and then hand off client connection responsibilities to the socket handler. The socket handler will then hand the client off to the echo implementation to work with as well as ensure it's ready for any extra connections. Finally, the echo implementation will just facilitate the server's functionality layer in. It will just send back to the client what ever it has given.<br /><h3>Code Walkthrough </h3>The main program is very simple. Setup the server socket using <a href="http://hackage.haskell.org/packages/archive/network/2.3.0.14/doc/html/Network.html#v:listenOn">listenOn</a> and then hand control over to the client handler.<br /><br /><script src="https://gist.github.com/tuttlem/5583842.js"></script> <br />The client handler (or socket handler as I called it above) accepts incoming client connections from the server socket using <a href="http://hackage.haskell.org/packages/archive/network/2.3.0.14/doc/html/Network.html#v:accept">accept</a>. We can then set buffering options (to off) for the client connection with <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hSetBuffering">hSetBuffering</a>. From there we make the echo service implementation fire up on a thread of its own with <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkIO">forkIO</a>. <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Concurrent.html#v:forkIO">forkIO</a> deserves a blog post of its own (as does the Concurrency module as a whole), and it will get one... just not today. Anyway, finally the client handler recurses on itself to handle the next client.<br /><br />It's a lot of text for some pretty simple code in the end.<br /><br /><script src="https://gist.github.com/tuttlem/5583932.js"></script> <br />Finally, we have the actual implementation. This is the code that makes our server an echo server. We'll take a line of text in from the client socket using <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hGetLine">hGetLine</a> then we'll write it back to the client using <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hPutStrLn">hPutStrLn</a>.<br /><br /><script src="https://gist.github.com/tuttlem/5583956.js"></script> <br />And that's it. The full code listing for this echo server is below.<br /><br /><script src="https://gist.github.com/tuttlem/5583974.js"></script><br /><br /><h3>Final thoughts</h3>There is a fairly basic pattern that you can establish out of the module here that you can adapt for more complex servers of your own. Some further study of the IO system would be needed to develop binary communication protocols of your own, but if you're ok with plain text protocols - this should do just fine!<br /><br />Enjoy. <br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
<div class='comment'>
<div class='author'>Michael Tuttle</div>
<div class='content'>
That looks really cool - nice and neat and simple. Thanks for the tip!</div>
</div>
<div class='comment'>
<div class='author'>Unknown</div>
<div class='content'>
The pipes and pipes network libraries are worth a look too. They let you work at a higher level of abstraction which is nice and haskell-ey. Here&#39;s a 2-line echo server using them:<br />https://gist.github.com/jhickner/5589907</div>
</div>
</div>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2014/03/25/assembly-syntax-intel-at-t/">
            Assembly Syntax Intel At T
            <small>25 Mar 2014</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/03/24/xargs-i/">
            xargs -i
            <small>24 Mar 2014</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/03/19/a-quick-lap-with-mvar/">
            A Quick Lap with MVar
            <small>19 Mar 2014</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

  </body>
</html>
