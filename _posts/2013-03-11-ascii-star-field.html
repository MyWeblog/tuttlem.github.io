---
layout: post
title: ASCII Star field
date: 2013-03-11
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>With everything getting quite busy around here, I'd found less and less time to pay any attention to my Haskell programming adventures. I have found a little bit of time over the previous weekend to put together a small useless tidbit that incorporates some concepts that I'd like to use later.</div><div><br /></div><div>The project that I've put together is a 3D star field simulation, written to the terminal using a set of Haskell <a href="http://en.wikipedia.org/wiki/Ncurses">ncurses</a> bindings calls <a href="http://hackage.haskell.org/packages/archive/hscurses/1.3.0.2/doc/html/UI-HSCurses-Curses.html">hscurses</a>.</div><div><br /></div><div>Today's post will take you through the whole unit itself (don't worry, it's quite simple and short) but outline some of the challenges and implementation ideas.</div><div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-mn6VD5_GYis/UT3NS1QFArI/AAAAAAAAAnE/jR3qXLYta78/s1600/Screen+Shot+2013-03-11+at+10.25.01+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="247" src="http://2.bp.blogspot.com/-mn6VD5_GYis/UT3NS1QFArI/AAAAAAAAAnE/jR3qXLYta78/s320/Screen+Shot+2013-03-11+at+10.25.01+PM.png" width="320" /></a></div><div style="text-align: center;">Trust me, it's so much more impressive when it's in motion <b>*facepalm*</b></div><div style="text-align: center;"><b><br /></b></div></div><h3>Data structure</h3><div>The first job is to define a data structure that will suit our star field, or at least just 1 star in the field. We can make a list of these data structures later and call that list a "star field". Whilst there are some more interesting characteristics we could define about a star, I've gone very simplistic making the star nothing more than a point in 3D space using record syntax.</div><div><br /><script src="https://gist.github.com/tuttlem/5133608.js"></script></div><div><br />We have an x, y and z co-ordinate to define that our star is "somewhere".<br /><br /><h3>Playing god</h3><div>We're able to define a star now that we have the structure to define it. Now it's time to "create" a star somewhere in our universe. In the following code snippet, I've created a star using a random number generator and have adjusted the numbers so that 0 is the mid point. The range should work out from -1 up to 1 for the x and y axis' and -500 up to -1 for the z axis (with negative numbers travelling into the screen).</div><div><br /><script src="https://gist.github.com/tuttlem/5133634.js"></script></div><div><br /></div><div></div>Making a star just ends up being a little bit of random number generator management. We're using it three times, so we need to keep track of what it is throughout these generations and we'll also send it out at the end so that we can continue to use it.<br /><br />We can use this creation function in a recursive function that will allow us to build a randomized "field" of stars. Up above, I said that a star field was just a list of stars, and this is exactly what we return (plus the random number generator).<br /><br /><script src="https://gist.github.com/tuttlem/5133656.js"></script> <br />This is a little bit awkward, only because we also need to be able to get the random number generator back out once we've used it so that it can continue to be "further random" in our program.<br /><br /><h3>Moving through space</h3><div>Now that we've created a universe of stars (or a star field), we now need to be able to move ourselves within the field. To simulate this movement, all we're going to do is increment the z position of each star. Now we all know that it's not actually the stars that move, it should be us - but, we're in a computer simulation, so we'll just pretend.</div><div><br /></div><div>The code is pretty straight forward. It'll take a list of stars (or a star field) in - increment the z co-ordinate for each and send out the adjusted list.</div><div><br /><script src="https://gist.github.com/tuttlem/5133720.js"></script></div><div><br /></div><div><br /></div><div><h3>Don't go through the screen!!</h3></div><div>We're incrementing these stars, over-and-over-and-over ... they're going to make it out of the screen, eeiiik! Even worse, they could get stuck right on the surface of the monitor screen! Whilst this may sound ok right now, later on we're going to "project" these 3D co-ordinates onto a 2D plane. In order to do this, we'll be dividing by that z co-ordinate, so we're really not in the business of dividing by zero here.</div><div><br /></div><div>The following function will determine which stars need to be removed "dead", which stars are still "good" and it will also generate new stars for us if need be.</div><div><br /></div><div>Of course, in the off chance that we do need to generate more stars, we must supply the random number generator to do so.</div><div><br /><script src="https://gist.github.com/tuttlem/5133758.js"></script></div><div><br /></div><div><br /></div><div><h3>3D Projection</h3></div><div>Turning a 3D point into a 2D point is a fairly straight-forward operation (if you've got all the facts). There are much, much, much more complex ways to do this but for the purposes of this demo I have simply divided by the z co-ordinate and added an offset based on the screen size.</div><div><br /><script src="https://gist.github.com/tuttlem/5133766.js"></script></div><div><br /></div><div><br /></div><div>We take in a star, the screen width and screen height. The formula ends up looking something like this:<br /><br /><pre>x_2d = ((x_3d * 127) / z_3d) + (width / 2)<br />y_2d = ((y_3d * 127) / z_3d) + (height / 2)</pre><br /></div>The constant 127 just gives us and adjustment for our viewport. It works quite well for this purpose, but you can read up more on the topic <a href="http://en.wikipedia.org/wiki/3D_projection">here</a>.<br /><br /><h3>Processing a frame</h3></div><div>To move through one "quantum" of time in our star field we really want to move the stars and make sure we're not going to do anything bad when we go to do our projections. So using advance and process, we can wrap this up for a frame like so.</div><div><br /><script src="https://gist.github.com/tuttlem/5133815.js"></script></div><div><br /></div><div>Most of the management of the star field is done now. We can now draw our star field using curses. Before we do that, lets look at some of these ncurses bindings for Haskell through hscurses.<br /><br /><h3>Setting the scene</h3></div><div>The following code is pretty well commented and these curses calls align pretty well to their native library analogs. All of the custom code mentioned in here will only be for our star field. Here's the main function for our star field.</div><div><br /><script src="https://gist.github.com/tuttlem/5133857.js"></script></div><div><br /></div><div><br /></div><div>The actual work of the star field is buried within "runStars" which I've commented below also.<br /><br /><script src="https://gist.github.com/tuttlem/5133873.js"></script></div><div><br />Finally, actually drawing a star. This is so simple. We move to the correct character cell and we put (of course) an asterisk!<br /><br /><script src="https://gist.github.com/tuttlem/5133890.js"></script> You can see that I've assumed the terminal to be 80x25, but it's easy enough to ask curses what the dimensions of the terminal are and adjust them accordingly.<br /><br /><h3>Conclusion</h3></div><div>Well, that's it really. It's simple, crude but so nerdy :-)</div><div><br /></div><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
