<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Diving into OpenCL &middot; Cogs and Levers
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A place for thoughts, ideas, tutorials and bookmarks. My brain can only hold so much, you know.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/tuttlem/tuttlem.github.io">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">Cogs and Levers</a>
            <small>A blog full of technical stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Diving into OpenCL</h1>
  <span class="post-date">27 Nov 2013</span>
  <h1>Diving into OpenCL</h1>
<div class='post'>
<h3>Introduction</h3><div>In a <a href="http://cogsandlevers.blogspot.com.au/2013/11/setup-debian-for-opencl-development.html">previous article</a>&nbsp;I'd put together a walk through on how to get your development environment ready to write some <a href="http://www.khronos.org/opencl/">OpenCL</a> code. This article by itself isn't of much use unless you can write some code already.</div><div><br /></div><div>Today's post will be a walk through on writing your first OpenCL program. This example, much like a lot of the other entry-level OpenCL development tutorials will focus on performing addition between two lists of floating point numbers.</div><br /><h3>Lots to learn</h3><div>Unfortunately, OpenCL is a topic that brings a very steep learning curve. In order to understand even the most simple of programs you need to read a fair bit of code and hopefully be aware of what it's doing. Before we dive into any implementation, I'll take you on a brief tour of terms, types and definitions that will help you to understanding the code as it's presented.<br /><br /><br /></div><b>cl_platform_id</b><br /><div>A cl_platform_id is obtained using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetPlatformIDs.html">clGetPlatformIDs</a>. A platform in OpenCL refers to the host execution environment and any attached devices. Platforms are what allow OpenCL to share resources and execute programs.<br /><br /></div><b>cl_device_id</b><br /><div>A cl_device_id is obtained using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceIDs.html">clGetDeviceIDs</a>. It's how your program will refer to the devices that your code will run on. A device is how OpenCL refers to "something" that will execute code (CPU, GPU, etc).<br /><br /></div><b>cl_context</b><br /><div>A cl_context is obtained using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateContext.html">clCreateContext</a>. A context is established across OpenCL devices. It's what OpenCL will use to manage command-queues, memory, program and kernel objects. It provides the ability to execute a kernel across many devices.<br /><br /></div><b>cl_program</b><br /><div>A cl_program is created from actual (string) source-code at runtime using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateProgramWithSource.html">clCreateProgramWithSource</a>. They're created in conjunction with your context so that program creation is aware of where it'll be expected to run.</div><div><br /></div><div>After the cl_program reference is successfully established, the host program would typically call <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clBuildProgram.html">clBuildProgram</a>&nbsp;to take the program from its source code (string) state into an executable (binary) state.<br /><br /></div><b>cl_command_queue</b><br /><div>A cl_command_queue is established using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateCommandQueue.html">clCreateCommandQueue</a>. A command queue is how work is scheduled to a device for execution. <br /><br /></div><b>cl_kernel</b><br /><div>A cl_kernel is created using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateKernel.html">clCreateKernel</a>. A kernel is a function contained within a compiled cl_program object. It's identified within the source code with a __kernel qualifier. You set the argument list for a cl_kernel object using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clSetKernelArg.html">clSetKernelArg</a>. To glue it all together, you use <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueNDRangeKernel.html">clEnqueueNDRangeKernel</a>&nbsp;or <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueTask.html">clEnqueueTask</a>&nbsp;to enqueue a task on the command queue to execute a kernel.</div><div><br /></div><div>A side note here is that you can use <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueNativeKernel.html">clEnqueueNativeKernel</a>&nbsp;to execute native C/C++ code that isn't compiled by OpenCL.</div><div><br /></div><div>At least if you can identify some form of meaning when you come across these type names, you won't be totally in the dark. Next up, we'll create a host program and OpenCL routine - compile, build and run!</div><br /><h3>The Host</h3><div>The host application is responsible for engaging with the OpenCL api to setup all of the objects described above. It's also responsible for locating the OpenCL source code and making it available for compilation at run time.<br /><br />In this first snippet of code, we use the OpenCL api to establish the management platform and devices that are available to execute our code. Majority of the OpenCL api standardises itself around returning error codes from all of the functions.<br /><br /><script src="https://gist.github.com/tuttlem/7669868.js"></script></div>At this point, we have "platform" which will (<i>hopefully</i>) contain a platform ID identifying our management platform and "device" should either refer to the GPU or CPU (failing to find a GPU).<br /><div><br />The next step is to create a context and your OpenCL program from source.<br /><br /><script src="https://gist.github.com/tuttlem/7669938.js"></script></div>We've done just that here, but the program isn't quite yet ready for execution. Before we can start using this, we need to build the program. The build process is very much a compilation &amp; linking process that involves its own set of log message outputs, etc. You can make this part of your program as elaborate as you'd like. Here's an example compilation process.<br /><br /><script src="https://gist.github.com/tuttlem/7670168.js"></script> We've got a platform, device, context and program that's been built. We now need to shift contexts from the host program to the actual OpenCL code that we'll execute for the purposes of this example. We need to understand what the inputs, outputs, used resources, etc. of the OpenCL code is before we can continue to write the rest of our host. <br /><br /><h3>The OpenCL Code</h3><div>The main purpose of OpenCL code is really to operate arithmetically on arrays (or strings) of data. The example that I'm suggesting for the purposes of this article takes in two source arrays and produces another array which are the sum of each index. i.e.<br /><br /><pre>c[0] = a[0]&nbsp;+ b[0]<br />c[1] = a[1]&nbsp;+ b[1]<br />. . .<br />. . .<br /></pre><br />As above, the source arrays are "a" and "b". The result array (holding the sum of each source array at each index) is "c".<br /><br />Here's the (rather simple) OpenCL code to achieve this.<br /><br /><script src="https://gist.github.com/tuttlem/7675033.js"></script></div>That's all there is to it. Things to note are, any function that is to be called in the OpenCL context is called a "kernel". Kernel's must be decorated with the "__kernel" modifier. In this example, the parameters that are passed in are decorated with the "__global" modifier. This tells OpenCL that these are objects allocated from the global memory pool. You can read up more about these modifiers <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/global.html">here</a>.<br /><br />The final thing to note is the use of <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/get_global_id.html">get_global_id</a>. It's what gives us the particular index to process in our array here. The parameter that's supplies allows you to work with 1, 2 or 3 dimensional arrays. Anything over this, the arrays need to be broken down to use a smaller dimension count.<br /><div><br /><h3>Back to the Host</h3></div><div>Back in context of the host, we'll create the command queue and kernel objects. The command queue allows us to send commands to OpenCL like reading &amp; writing to buffers or executing kernel code. The following code shows the creation of the command queue and kernel.<br /><br /><script src="https://gist.github.com/tuttlem/7675267.js"></script> Notice that we mentioned the kernel by name here. A kernel object refers to the function!<br /><br />Now that we have a function to execute (or kernel) we now need to be able to pass data to the function. We also need to be able to read the result once processing has finished. Our first job is allocating buffers that OpenCL will be aware of to handle these arrays.</div><div><br /></div><script src="https://gist.github.com/tuttlem/7675181.js"></script> <br /><div><br /></div>In the above snippet, we've defined the source arrays and we've also created buffers that will hold the information (for use in our OpenCL code). Now all we need to do is to feed the source arrays into the buffers and supply all of the buffers as arguments to our kernel.<br /><br /><script src="https://gist.github.com/tuttlem/7675340.js"></script> Now we invoke OpenCL to do the work. In doing this, we need to supply the invocation with a global size and local size. Global size is used to specify the total number of work items being processed. In our case, this is ARRAY_SIZE. Local size is used as the number of work items in each local group. Local size needs to be a divisor of global size. For simplicity, I've set these both to "ARRAY_SIZE".<br /><br /><script src="https://gist.github.com/tuttlem/7675450.js"></script> After all of the work is completed, we really want to take a look at the result. We'll send another request to the command queue to read that result array back into local storage. From there, we'll be able to print the results to screen.<br /><br /><script src="https://gist.github.com/tuttlem/7675493.js"></script> Fantastic. Everything's on screen now, we can see the results. All we'll do from here is clean up our mess and get out.<br /><script src="https://gist.github.com/tuttlem/7675542.js"></script> <br />What a marathon! Hopefully you've learnt something from this post. It's a lot to take in to get a "Hello, World" level application up and running.<br /><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

</div>

<div class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/2014/03/25/assembly-syntax-intel-at-t/">
            Assembly Syntax Intel At T
            <small>25 Mar 2014</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/03/24/xargs-i/">
            xargs -i
            <small>24 Mar 2014</small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/2014/03/19/a-quick-lap-with-mvar/">
            A Quick Lap with MVar
            <small>19 Mar 2014</small>
          </a>
        </h3>
      </li>
    
  </ul>
</div>

      </div>
    </div>

  </body>
</html>
