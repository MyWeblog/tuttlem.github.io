---
layout: post
title: Hello, Haskell (from the web)!
date: 2012-12-25
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3>The best part about technology is the ability to use anything you want. I've run across many frameworks all touting their own awesomeness. Sometimes though, you just need to smash a bit of output back to the client.<br /><br />Using the CGI and XHTML libraries available for Haskell, web programming is so simple. Just about every web server known to mankind can run a CGI program and if yours can't, it may need a trip to the gym.<br /><br /><h3>Show me some code</h3>Excellent. This is where it gets very interesting. I realise at first, when you're reading this code you're going to be saying "well, duh - I can knock out a HTML page to be statically served much easier than this B.S."<br /><br />If this is your train of thought, you may have missed the point. The example I provider here is only to demonstrate to the reader how we can get Haskell closer to the client generation.<br /><br /><script src="https://gist.github.com/4372983.js"></script> This should be fairly easy to follow. There's nothing out of the ordinary and it's very simple. After reading <a href="http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell">this document</a> I was impressed that this could be condensed down into the following:<br /><br /><script src="https://gist.github.com/4372991.js"></script> <br />Damn! Not bad.<br /><br />And, here's the output that you get from running these CGI programs:<br /><br /><script src="https://gist.github.com/4373004.js"></script> <br />At the moment, I can see how this looks like a long way around and it certainly is a feathers over steam-train approach to delivering a static page but we've now got the power of Haskell behind our CGI program.<br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>
