---
layout: post
title: A simple C++ INI file reader
date: 2012-12-26
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>I've been looking for a simple way to quickly supply some of my applications with easy-access configuration information. Most of the times these are games and smaller utility applications. Enterprise scale applications deserve configuration systems of their own gargantuan proportions, but that's another story.</div><div><br /></div><div>Thinking back quite a few years, the windows crew had a pretty simple way to supply this sort of information to their running programs, they used the <a href="http://en.wikipedia.org/wiki/INI_file">INI file format</a>.</div><h3>How's it look?</h3><div>It's a pretty basic, plain-text format. Typically you'd see something along the lines of:</div><div><br /><pre>[section]<br />key1=value<br />key2=value<br />key3=value<br />...<br />[another section]<br />...<br />...<br /></pre></div><div><br />You get the idea. The wikipedia link above will give you a more thorough run-down should you need it.<br /><h3>How to make it usable?</h3></div><div>The aim is to basically feed an INI file into this process and have some very easy to use C++ objects out the other side. The <a href="http://en.wikipedia.org/wiki/Standard_Template_Library">STL</a>&nbsp;contains some very suitable container style objects that will measure up, so I want something like this:</div><div><br /><script src="https://gist.github.com/4379548.js"></script></div><div><br /></div><div><br /></div><div>The map class is a convenient way to manage key-value pairs. Perfect.<br /><br />Looking at the code, the types are very long-winded. All of the namespace declaration actually mixed with the types makes for a very long line. This can be cleaned up by "using" the std namespace, but the whole type definition itself could be cleaned up by just using a typedef. I'll be writing the types long-hand for the duration of this tutorial, just so we're clear.<br /><br /><h3>Doing it smart</h3><div>Thanks to the rigid format of the file, we've got a very solid standard set in place as to what we'll expect when we crack the file open. We can centralise all of our file processing around two regular expressions.</div><div><br /></div><pre>\[(.*?)\]</pre><div><br /></div>This first regular expression is our test for the section parts. It tests that the line being interpreted is wrapped in square brackets. When we run this through the regular expression system, it'll allow us to extract just the name. Nice.<br /><br /><pre>(\w+)=([^\+]+(?!\+{3}))</pre><br />This second expression will do our key value pair testing. When we use it in extraction with a regular expression, the first match will be the key, the second - the value. Double nice.<br /><br />So, we can fire these regular expressions up using the <a href="http://www.boost.org/doc/libs/1_52_0/libs/regex/doc/html/index.html">boost regex library</a>. I'm led to believe that parts of the boost library will be appearing in the newest C++ standard, regular expressions being one of them.<br /><br /><h3>Putting it all together</h3></div><div>The block of code in the end is quite simple.&nbsp;</div><div><br /><script src="https://gist.github.com/4379662.js"></script></div><div><br /></div><div>So, with a couple of tests to assure us that the values are ok we've got a pretty crude implementation here. Erroneous lines are ignored rather than responded to in an exception case. If no initial section is supplied before some key value pairs, those pairs will go into an item section with an empty string.<br /><br />Anyway, if the user is half-sane about how they treat their INI files, you'll be just fine.</div><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
