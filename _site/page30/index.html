<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Cogs and Levers &middot; A blog full of technical stuff
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A place for thoughts, ideas, tutorials and bookmarks. My brain can only hold so much, you know.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/tuttlem/tuttlem.github.io">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">Cogs and Levers</a>
            <small>A blog full of technical stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/28/clojure-and-leiningen-quickstart/">
        Clojure and Leiningen quickstart
      </a>
    </h1>

    <span class="post-date">28 Dec 2012</span>

    <h1>Clojure and Leiningen quickstart</h1>
<div class='post'>
<h3>Introduction</h3><div><a href="http://clojure.org/">Clojure</a> is the modern <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">LISP</a>. Clojure is an elegant, dynamic programming language that runs a-top the JVM. In today's post, I'll show you how to get started with Clojure &amp; <a href="http://leiningen.org/">Leiningen</a>.</div><h3><br /></h3><h3>Getting installed</h3><div>I've written this article from the perspective of a Debian user. Translating these steps into your own native environments should be as easy as re-structuring the installation steps to target your package manager of choice.</div><div><br /></div><div>Installing Clojure &amp; Leiningen was a simple as this:</div><div><pre># aptitude install clojure leiningen</pre></div><div><br /></div><div>You're done. You should now have Clojure and Leiningen at your disposal.</div><div><h3><br /></h3><h3>Initial steps</h3></div><div>You'll want to kick the tires on this puppy, so from your bash prompt fire up the REPL environment and try a few commands:</div><div><br /><pre>$ clojure<br /><br />Clojure 1.2.1<br />user=&gt; (+ 2 4)<br />6<br /><br />user=&gt; (print "Clojure is installed!")<br />Clojure is installed!nil<br /><br />user=&gt; (if (= 1 1) (print "Yes, 1 does equal 1") (print "Mathematics just stopped<br />working"))<br />Yes, 1 does equal 1nil<br /></pre></div><div><br /></div><div>Alright! Enough of this already. Let's generate a project.<br /><br /><a href="http://leiningen.org/">Leiningen</a>&nbsp;is a painless way to get started on your Clojure project. All you have to do, is issue the following commands and you've got a project ready to go:<br /><br /><pre>$ lein new projname</pre><br /></div><div>Where "projname" is the name of your project. For this test, I just called mine "myproj". If you have a look inside the directory that Leiningen has just generated for you, you'll see the following sub-directories:<br /><br /><pre>lib         - holds your programs dependencies<br />project.clj - a clojure file describing your project <br />README      - duh! <br />src         - your source files <br />test        - any tests for your application<br /></pre><br />This is a pretty neat-and-tidy layout, ready for you to start coding.<br /><br /><h3>Bulding and running and cleaning, oh my!</h3><div>Leiningen also makes it very easy to build, run and cleanup your project. Here's how. From within your project directory:</div><div><br />You can build your project by:<br /><pre>$ lein compile</pre><br />You can clean any built files by:<br /><pre>$ lein clean</pre><br />You can run your project with:<br /><pre>$ lein run</pre></div><div><br /></div>Too easy.</div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/27/list-comprehension-in-haskell/">
        List comprehension in Haskell
      </a>
    </h1>

    <span class="post-date">27 Dec 2012</span>

    <h1>List comprehension in Haskell</h1>
<div class='post'>
<h3>Introduction</h3><div>Generating and operating on lists of data in languages is an essential tool when doing even the most basic of processing. List comprehension is just this process. It's prevalent in most of today's languages and today I want to post about <a href="http://www.haskell.org/haskellwiki/List_comprehension">this process in Haskell</a>.</div><div><br /></div><h3>A numeric example</h3><div>Working with numeric data is probably the easiest of examples to help you grasp this concept. Let's start by using a list comprehension to generate a list of numbers 1-through-5.<br /><br /></div><pre>[x | x &lt;- [1..5]]</pre><br />This will return a list looking like [1, 2, 3, 4, 5]. Analysing what we've just written here, we can see that what we want to return is on the left hand side of the pipe "|" symbol, how we want to generate each value sits on the right hand side of the pipe symbol. This expression is wrapped in square braces because we want a list!<br /><br />We can change this ever so slightly to only give us back odd numbers like so:<br /><br /><pre></pre><pre></pre><pre>[x | x &lt;- [1..5], odd x]</pre><br />You can see that we've just concatenated another piece of criteria to the right hand side of the expression specifying that we only want odd numbers. We then end up with a list looking like [1, 3, 5]. These are still very simple examples, but we can do some very powerful things with these expressions.<br /><br />Take the following for example.<br /><br /><pre>[x * y | x &lt;- [1..5], y &lt;- [1..5]]</pre><br />Looking at the left-hand side you can see that we want the multiple of x and y. On the right-hand side you can see that both x and y iterate 1-through-5, so we end up with the following:<br /><br /><pre>[1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,5,10,15,20,25]</pre><br />Now we're getting somewhere.<br /><h3>Not so numeric, but close</h3><div>When I first saw this technique employed, I'd immediately seen its use in many places. The first place that I decided to put it though was <a href="http://cogsandlevers.blogspot.com.au/2012/11/i-need-to-crawl-before-i-can-walk-so.html">generating a deck of card</a>. This link is to an Uno implementation that I tried out in Haskell, and if you're&nbsp;familiar&nbsp;with the game, you have colour cards and you have wild cards, so I could represent a deck with the two following expressions:</div><div><br /></div><pre>[Card v (Just c) | v &lt;- [Naught .. DrawTwo], c &lt;- [Red .. Yellow]]<br />[Card v Nothing | v &lt;- [Wild .. WildDrawFour]]</pre><div><br /></div><div>These two expressions gave me a deck of cards ready to shuffle! No "for-loops" here ma!<br /><br /><h3>Strings are just arrays of chars!</h3></div><div>Correct, they are. So it should be no surprise that this statement:<br /><br /><pre>[a | a &lt;- ['a'..'z']</pre><br /></div>generates a string that looks like this:<br /><br /><pre>"abcdefghijklmnopqrstuvwxyz"</pre><br />Pretty easy/obvious.<br /><br />The complexities of list processing and generation can be greatly simplified in your code if you can master the list comprehension.<br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/27/folding-in-haskell/">
        Folding in Haskell
      </a>
    </h1>

    <span class="post-date">27 Dec 2012</span>

    <h1>Folding in Haskell</h1>
<div class='post'>
<h3>Introduction</h3><div>In this post I would like to present some basic concepts in folding. This really will be over in a flash, so don't blink - it's easy.</div><h3>tl;dr</h3><div>The Haskell functions <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:foldl">foldl</a> and <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:foldr">foldr</a> allow you to "fold" functions between values.</div><h3>Diagram it for me!</h3><div>If you read up on these functions in the documentation, you'll see mention of "reducing values in a list" and such. All this really means, is that you're going to iterate through a list apply a function at every stop and finish up with a "reduced" answer.</div><div><br /></div><div>Here, take a look at this. I have an array spanning 1 through 5.<br /><br /><pre>[1, 2, 3, 4, 5]</pre><br /></div><div>I want to add all of the values together, so I use&nbsp;<a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:foldl">foldl</a>&nbsp;to move through the list applying the "+" operator.<br /><br /><pre>foldl (+) 0 [1,2,3,4,5]</pre><br />This command in english says, apply the "+" operator between each element in the list (moving left to right) with an initial value of 0. Or:<br /><br /><pre>0 + 1 + 2 + 3 + 4 + 5 = 15</pre><br /><h3>Bring it back the other way!</h3></div><div>Folding right is interesting. No so much for the example that we have above, as addition moving left or right is at identity with each other.&nbsp;I've prepared a more interesting example for moving to the right.</div><div><br />Take a look at the following and the results:<br /><br /><pre>foldl (-) 10 [10, 20, 30]<br />-50<br /><br />foldr (-) 10 [10, 20, 30]<br />10</pre><br />Wow, that's quite the difference. When folding right, the reduction occurs in reverse (values right to left) and then it's applied to the initial value.<br /><br /><pre>(foldl)</pre><pre>10 - 10 - 20 - 30     = -50 </pre><pre></pre><pre>(foldr)</pre><pre>10 - (20 - (30 - 10)) = 10</pre><br />So, there we are folding to the right!&nbsp;That's (very basic) folding for you anyway.<br /><br />An interesting follow-up to this article is the function foldl'. By nature foldl that we've just discussed is lazy, meaning it will build the list of computations to execute using the source array and only execute those computations once the array is depleted (internally). It's been shown that this model of execution can cause stack overflow errors for larger lists because of this deferred execution model. foldl' solves this by not deferring execution. So, the overall result will be the same it's just that foldl' won't be lazy in getting the answer back to you.<br /><br /><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/26/function-currying-in-haskell/">
        Function currying in Haskell
      </a>
    </h1>

    <span class="post-date">26 Dec 2012</span>

    <h1>Function currying in Haskell</h1>
<div class='post'>
I think it's important to follow up my previous post on <a href="http://cogsandlevers.blogspot.com.au/2012/12/anonymous-functions-in-haskell.html">anonymous functions</a>&nbsp;with a post on currying. One of the more difficult concepts to think about (only because Haskell does a great job of separating you from this) is that every function only has 1 argument.<br /><br />Take this basic greeting example which expects the name of someone who is doing the greeting and the name of someone who is being greeted:<br /><br /><script src="https://gist.github.com/4377706.js"></script> <br />This is a pretty trivial example. Give it two names and the computer will appear to play nice between these two people:<br /><br /><pre>*Main&gt; sayHello "John" "Peter"<br />"Peter says Hello to John"</pre><br />We like John so much, that we're going to make a new function using this existing one.<br /><script src="https://gist.github.com/4377714.js"></script> <br />So now, we can get anyone to play nice with John:<br /><br /><pre>*Main&gt; sayHelloToJohn "Peter"<br />"Peter says Hello to John"<br />*Main&gt; sayHelloToJohn "Joe"<br />"Joe says Hello to John"<br />*Main&gt; sayHelloToJohn "Jane"<br />"Jane says Hello to John"</pre><br />Great! We've just made a partially applied function. When you don't specify enough parameters to a function, you're actually returned a function (or, partially applied function) that you can continue to use.&nbsp;Breaking down how this works, when Jane is saying hello to John she is actually doing so by doing this:<br /><br /><script src="https://gist.github.com/4377723.js"></script> This should at least explain my outlandish claims above of functions only having one argument, anyway.<br /><br />You've just witnessed function currying in motion.<br /><br />These principles are also directly applicable on infix functions as well, they just need a little extra help to be told so. Take this for example:<br /><br /><script src="https://gist.github.com/4385044.js"></script> <br />Ignoring the function definition, you can see that all you need to do for infix functions is to&nbsp;surround then with parenthesis. You need to supply the value that makes it a partial application of course!<br /><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2012/12/26/function-composition-in-haskell/">
        Function composition in Haskell
      </a>
    </h1>

    <span class="post-date">26 Dec 2012</span>

    <h1>Function composition in Haskell</h1>
<div class='post'>
<a href="http://en.wikipedia.org/wiki/Function_composition">Function composition</a> is a no-brainer concept <a href="http://www.haskell.org/haskellwiki/Function_composition">for Haskell</a> that makes a lot of sense. It's truly aligned with its mathematical equivelant where you have two given functions:<br /><br /><pre>f(x) = x * x<br />g(x) = x + 2</pre><br />The composition part comes in when you nest these functions, so that you end up with:<br /><br /><pre>f(g(x)) = f(x + 2)<br />f(g(x)) = (x + 2) * (x + 2)<br />f(g(x)) = x^2 + 4x + 4</pre><br />Mathematically, this is cake. We just nest the second function inside the first. If we look at it with respect to Haskell we end up with this:<br /><br /><script src="https://gist.github.com/4380029.js"></script> <br />So, the "." operator is doing the composition here for us. Below I've got the mathematical representation on the left, Haskell on the right.<br /><br /><pre>f(g(x)) = (f . g) x</pre><br />The real power here is that you can use function composition with any two functions, just as long as the &nbsp;return type of the second function is the same as the argument taken by the first function.<br /><br />Slick.</div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page31">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page29">Newer</a>
    
  
</div>
      </div>
    </div>

  </body>
</html>
