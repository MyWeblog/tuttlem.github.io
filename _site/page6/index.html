<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
    
      Cogs and Levers &middot; A blog full of technical stuff
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/public/css/poole.css">
  <link rel="stylesheet" href="/public/css/syntax.css">
  <link rel="stylesheet" href="/public/css/lanyon.css">
  <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
</head>


  <body>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <div class="sidebar-item">
    <p>A place for thoughts, ideas, tutorials and bookmarks. My brain can only hold so much, you know.</p>
  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="/">Home</a>

    

    
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    

    <a class="sidebar-nav-item" href="https://github.com/tuttlem/tuttlem.github.io">GitHub</a>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; 2014. All rights reserved.
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <label for="sidebar-checkbox" class="sidebar-toggle"></label>

          <h3 class="masthead-title">
            <a href="/" title="Home">Cogs and Levers</a>
            <small>A blog full of technical stuff</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="posts">
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/12/30/a-camera-implementation-in-c/">
        A Camera Implementation in C++
      </a>
    </h1>

    <span class="post-date">30 Dec 2013</span>

    <h3 id="introduction">Introduction</h3>

<p>One of the most important elements of any 3D application is its camera. A camera allows you to move around in your world and orient your view. In today&#39;s post, I&#39;ll put together a code walk through that will take you through a simple camera implementation.</p>

<h3 id="the-concept">The Concept</h3>

<p>There are two major components of any camera. They are position and orientation. Position is fairly easy to grasp, it&#39;s just where the camera is and is identified using a normal 3-space vector.</p>

<p>The more difficult of the two concepts is orientation. The best description for this that I&#39;ve found is on the <a href="http://en.wikipedia.org/wiki/Flight_dynamics">Flight Dynamics</a> page on wikipedia. The following image has been taken from that article and it outlines the plains that orientation can occur. Of course, the image&#39;s subject is an aircraft but the same concepts apply to a camera&#39;s orientation:</p>

<p><img src="http://2.bp.blogspot.com/-ps-FvMLXC0U/UsEQcjCw5gI/AAAAAAAAAxk/v-ZbdV9aAfc/s1600/Rollpitchyawplain.png" alt="Roll pitch yaw"></p>

<p>The <em>pitch</em> describes the orientation around the x-axis, the <em>yaw</em> describes the orientation around the y-axis and the <em>roll</em> describes the orientation around the z-axis.</p>

<p>With all of this information on board, the requirements of our camera should become a little clearer. We need to keep track of the following about the camera:</p>

<ul>
<li>Position</li>
<li>Up orientation (yaw axis)</li>
<li>Right direction (pitch axis)</li>
<li>Forward (or view) direction (roll axis)</li>
</ul>

<p>We&#39;ll also keep track of how far we&#39;ve gone around the yaw, pitch and roll axis.</p>

<h3 id="some-maths-(and-code)">Some Maths (and code)</h3>

<p>There&#39;s a handful of really useful equations that are going to help us out here. With all of the information that we&#39;ll be managing and how tightly related each axis is considering they&#39;re all relating to the same object - you can see how interactive it can be just by modifying one attribute.</p>

<p>When the <strong>pitch</strong> changes:</p>

<div class="highlight"><pre><code class="text">forwardVector = (forwardVector * cos(pitch)) + (upVector * sin(pitch))
upVector      = forwardVector x rightVector</code></pre></div>

<div class="highlight"><pre><code class="cpp"><span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">pitch</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// keep track of how far we&#39;ve gone around the axis</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">rotatedX</span> <span class="o">+=</span> <span class="n">angle</span><span class="p">;</span>

  <span class="c1">// calculate the new forward vector</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span> <span class="o">*</span> <span class="n">cosf</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">PION180</span><span class="p">)</span> <span class="o">+</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span> <span class="o">*</span> <span class="n">sinf</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">PION180</span><span class="p">)</span>
  <span class="p">);</span>

  <span class="c1">// calculate the new up vector</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span>  <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span><span class="p">);</span>
  <span class="c1">// invert so that positive goes down</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>When the <strong>yaw</strong> changes:</p>

<div class="highlight"><pre><code class="text">forwardVector = (forwardVector * cos(yaw)) - (rightVector * sin(yaw))
rightVector   = forwardVector x upVector</code></pre></div>

<div class="highlight"><pre><code class="cpp"><span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">yaw</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// keep track of how far we&#39;ve gone around this axis</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">rotatedY</span> <span class="o">+=</span> <span class="n">angle</span><span class="p">;</span>

  <span class="c1">// re-calculate the new forward vector</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span> <span class="o">*</span> <span class="n">cosf</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">PION180</span><span class="p">)</span> <span class="o">-</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span> <span class="o">*</span> <span class="n">sinf</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">PION180</span><span class="p">)</span>
  <span class="p">);</span>

  <span class="c1">// re-calculate the new right vector</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>When the <strong>roll</strong> changes:</p>

<div class="highlight"><pre><code class="text">rightVector = (rightVector * cos(roll)) + (upVector * sin(roll))
upVector    = forwardVector x rightVector</code></pre></div>

<div class="highlight"><pre><code class="cpp"><span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">roll</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">angle</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// keep track of how far we&#39;ve gone around this axis</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">rotatedZ</span> <span class="o">+=</span> <span class="n">angle</span><span class="p">;</span>

  <span class="c1">// re-calculate the forward vector</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span> <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span> <span class="o">*</span> <span class="n">cosf</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">PION180</span><span class="p">)</span> <span class="o">+</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span> <span class="o">*</span> <span class="n">sinf</span><span class="p">(</span><span class="n">angle</span> <span class="o">*</span> <span class="n">PION180</span><span class="p">)</span>
  <span class="p">);</span>

  <span class="c1">// re-calculate the up vector</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span>  <span class="o">=</span> <span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span><span class="p">);</span>
  <span class="c1">// invert the up vector so positive points down</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>Ok, so that&#39;s it for orientation. Reading through the equations above, you can see that the calculation of the forward vector comes out of some standard rotations. The <code>x</code> operator that I&#39;ve used above denotes vector <strong>cross product</strong>.</p>

<p>Now that we&#39;re keeping track of our current viewing direction, up direction and right direction; performing camera movements is really easy.</p>

<p>I&#39;ve called these <code>advance</code> (move along the forward plane), <code>ascend</code> (move along the up plane) and <code>strafe</code> (move along the right plane).</p>

<div class="highlight"><pre><code class="cpp"><span class="c1">// z movement</span>
<span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">+=</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span> <span class="o">*</span> <span class="o">-</span><span class="n">distance</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// y movement</span>
<span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">ascend</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">+=</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">upVector</span> <span class="o">*</span> <span class="n">distance</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// x movement</span>
<span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">strafe</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span> <span class="n">distance</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">+=</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">rightVector</span> <span class="o">*</span> <span class="n">distance</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>All we are doing here is just moving along those planes that have been defined for us via orientation. Movement is simple.</p>

<h3 id="integrating">Integrating</h3>

<p>All of this code/math is great up until we need to apply it in our environments. Most of the work that I do centralises around OpenGL, so I&#39;ve got a very handy utility function (from GLU) that I use called <a href="http://www.opengl.org/sdk/docs/man2/xhtml/gluLookAt.xml">gluLookAt</a>. Plugging these values in is rather simple:</p>

<div class="highlight"><pre><code class="cpp"><span class="kt">void</span> <span class="n">camera</span><span class="o">::</span><span class="n">place</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">glm</span><span class="o">::</span><span class="n">vec3</span> <span class="n">viewPoint</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">position</span> <span class="o">+</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">viewDir</span><span class="p">;</span>

   <span class="c1">// setup opengl with gluLookAt</span>
  <span class="n">gluLookAt</span><span class="p">(</span>
    <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">position</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">viewPoint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">viewPoint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewPoint</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="n">upVector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">upVector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">upVector</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
  <span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>We calculate our viewpoint as (<code>position</code> - <code>forwardVector</code>) and really just plug the literal values into this function. There is a lot of information on the gluLookAt documentation page that you can use if OpenGL isn&#39;t your flavor to simulate what it does.</p>

<p>That&#39;s it for a simple camera! </p>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/12/28/getting-started-with-glut-in-linux/">
        Getting started with GLUT in Linux
      </a>
    </h1>

    <span class="post-date">28 Dec 2013</span>

    <h1>Getting started with GLUT in Linux</h1>
<div class='post'>
<h3>Introduction</h3><a href="http://www.opengl.org/resources/libraries/glut/">GLUT</a> is the OpenGL Utility Toolkit which is a standard set of APIs that you should be able to use on any platform to write OpenGL programs. It takes care of the boilerplate code that your applications would need to integrate with the host windowing system. More can be found about GLUT on its <a href="http://www.opengl.org/resources/libraries/glut/">website</a>.<br /><br />Today's post, I'll focus on getting your Linux environment up to speed to start writing programs with this framework.<br /><br /><h3>Installation</h3>In order to write programs using this library, you'll need to install the development library. Using your favorite package manager, you'll need to install freeglut.<br /><br /><pre class="brush: shell">$ sudo apt-get install freeglut3-dev<br /></pre><br />After that's finished, it's time to write a test application to make sure everything went to plan.<br /><br /><h3>A Simple Example</h3>The following program will just open a window and continually clear the window.<br /><br /><br /><script src="https://gist.github.com/tuttlem/8156737.js"></script> <br />Putting this code into "test.c", we built it into a program with the following command:<br /><br /><pre class="brush: shell">$ gcc test.c -lGL -lGLU -lglut -o test<br /></pre><br />That's it! Run "test" at the command prompt and if everything has gone to plan, you've installed freeglut correctly!<br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/27/diving-into-opencl/">
        Diving into OpenCL
      </a>
    </h1>

    <span class="post-date">27 Nov 2013</span>

    <h1>Diving into OpenCL</h1>
<div class='post'>
<h3>Introduction</h3><div>In a <a href="http://cogsandlevers.blogspot.com.au/2013/11/setup-debian-for-opencl-development.html">previous article</a>&nbsp;I'd put together a walk through on how to get your development environment ready to write some <a href="http://www.khronos.org/opencl/">OpenCL</a> code. This article by itself isn't of much use unless you can write some code already.</div><div><br /></div><div>Today's post will be a walk through on writing your first OpenCL program. This example, much like a lot of the other entry-level OpenCL development tutorials will focus on performing addition between two lists of floating point numbers.</div><br /><h3>Lots to learn</h3><div>Unfortunately, OpenCL is a topic that brings a very steep learning curve. In order to understand even the most simple of programs you need to read a fair bit of code and hopefully be aware of what it's doing. Before we dive into any implementation, I'll take you on a brief tour of terms, types and definitions that will help you to understanding the code as it's presented.<br /><br /><br /></div><b>cl_platform_id</b><br /><div>A cl_platform_id is obtained using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetPlatformIDs.html">clGetPlatformIDs</a>. A platform in OpenCL refers to the host execution environment and any attached devices. Platforms are what allow OpenCL to share resources and execute programs.<br /><br /></div><b>cl_device_id</b><br /><div>A cl_device_id is obtained using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clGetDeviceIDs.html">clGetDeviceIDs</a>. It's how your program will refer to the devices that your code will run on. A device is how OpenCL refers to "something" that will execute code (CPU, GPU, etc).<br /><br /></div><b>cl_context</b><br /><div>A cl_context is obtained using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateContext.html">clCreateContext</a>. A context is established across OpenCL devices. It's what OpenCL will use to manage command-queues, memory, program and kernel objects. It provides the ability to execute a kernel across many devices.<br /><br /></div><b>cl_program</b><br /><div>A cl_program is created from actual (string) source-code at runtime using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateProgramWithSource.html">clCreateProgramWithSource</a>. They're created in conjunction with your context so that program creation is aware of where it'll be expected to run.</div><div><br /></div><div>After the cl_program reference is successfully established, the host program would typically call <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clBuildProgram.html">clBuildProgram</a>&nbsp;to take the program from its source code (string) state into an executable (binary) state.<br /><br /></div><b>cl_command_queue</b><br /><div>A cl_command_queue is established using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateCommandQueue.html">clCreateCommandQueue</a>. A command queue is how work is scheduled to a device for execution. <br /><br /></div><b>cl_kernel</b><br /><div>A cl_kernel is created using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clCreateKernel.html">clCreateKernel</a>. A kernel is a function contained within a compiled cl_program object. It's identified within the source code with a __kernel qualifier. You set the argument list for a cl_kernel object using <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clSetKernelArg.html">clSetKernelArg</a>. To glue it all together, you use <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueNDRangeKernel.html">clEnqueueNDRangeKernel</a>&nbsp;or <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueTask.html">clEnqueueTask</a>&nbsp;to enqueue a task on the command queue to execute a kernel.</div><div><br /></div><div>A side note here is that you can use <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/clEnqueueNativeKernel.html">clEnqueueNativeKernel</a>&nbsp;to execute native C/C++ code that isn't compiled by OpenCL.</div><div><br /></div><div>At least if you can identify some form of meaning when you come across these type names, you won't be totally in the dark. Next up, we'll create a host program and OpenCL routine - compile, build and run!</div><br /><h3>The Host</h3><div>The host application is responsible for engaging with the OpenCL api to setup all of the objects described above. It's also responsible for locating the OpenCL source code and making it available for compilation at run time.<br /><br />In this first snippet of code, we use the OpenCL api to establish the management platform and devices that are available to execute our code. Majority of the OpenCL api standardises itself around returning error codes from all of the functions.<br /><br /><script src="https://gist.github.com/tuttlem/7669868.js"></script></div>At this point, we have "platform" which will (<i>hopefully</i>) contain a platform ID identifying our management platform and "device" should either refer to the GPU or CPU (failing to find a GPU).<br /><div><br />The next step is to create a context and your OpenCL program from source.<br /><br /><script src="https://gist.github.com/tuttlem/7669938.js"></script></div>We've done just that here, but the program isn't quite yet ready for execution. Before we can start using this, we need to build the program. The build process is very much a compilation &amp; linking process that involves its own set of log message outputs, etc. You can make this part of your program as elaborate as you'd like. Here's an example compilation process.<br /><br /><script src="https://gist.github.com/tuttlem/7670168.js"></script> We've got a platform, device, context and program that's been built. We now need to shift contexts from the host program to the actual OpenCL code that we'll execute for the purposes of this example. We need to understand what the inputs, outputs, used resources, etc. of the OpenCL code is before we can continue to write the rest of our host. <br /><br /><h3>The OpenCL Code</h3><div>The main purpose of OpenCL code is really to operate arithmetically on arrays (or strings) of data. The example that I'm suggesting for the purposes of this article takes in two source arrays and produces another array which are the sum of each index. i.e.<br /><br /><pre>c[0] = a[0]&nbsp;+ b[0]<br />c[1] = a[1]&nbsp;+ b[1]<br />. . .<br />. . .<br /></pre><br />As above, the source arrays are "a" and "b". The result array (holding the sum of each source array at each index) is "c".<br /><br />Here's the (rather simple) OpenCL code to achieve this.<br /><br /><script src="https://gist.github.com/tuttlem/7675033.js"></script></div>That's all there is to it. Things to note are, any function that is to be called in the OpenCL context is called a "kernel". Kernel's must be decorated with the "__kernel" modifier. In this example, the parameters that are passed in are decorated with the "__global" modifier. This tells OpenCL that these are objects allocated from the global memory pool. You can read up more about these modifiers <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/global.html">here</a>.<br /><br />The final thing to note is the use of <a href="http://www.khronos.org/registry/cl/sdk/1.0/docs/man/xhtml/get_global_id.html">get_global_id</a>. It's what gives us the particular index to process in our array here. The parameter that's supplies allows you to work with 1, 2 or 3 dimensional arrays. Anything over this, the arrays need to be broken down to use a smaller dimension count.<br /><div><br /><h3>Back to the Host</h3></div><div>Back in context of the host, we'll create the command queue and kernel objects. The command queue allows us to send commands to OpenCL like reading &amp; writing to buffers or executing kernel code. The following code shows the creation of the command queue and kernel.<br /><br /><script src="https://gist.github.com/tuttlem/7675267.js"></script> Notice that we mentioned the kernel by name here. A kernel object refers to the function!<br /><br />Now that we have a function to execute (or kernel) we now need to be able to pass data to the function. We also need to be able to read the result once processing has finished. Our first job is allocating buffers that OpenCL will be aware of to handle these arrays.</div><div><br /></div><script src="https://gist.github.com/tuttlem/7675181.js"></script> <br /><div><br /></div>In the above snippet, we've defined the source arrays and we've also created buffers that will hold the information (for use in our OpenCL code). Now all we need to do is to feed the source arrays into the buffers and supply all of the buffers as arguments to our kernel.<br /><br /><script src="https://gist.github.com/tuttlem/7675340.js"></script> Now we invoke OpenCL to do the work. In doing this, we need to supply the invocation with a global size and local size. Global size is used to specify the total number of work items being processed. In our case, this is ARRAY_SIZE. Local size is used as the number of work items in each local group. Local size needs to be a divisor of global size. For simplicity, I've set these both to "ARRAY_SIZE".<br /><br /><script src="https://gist.github.com/tuttlem/7675450.js"></script> After all of the work is completed, we really want to take a look at the result. We'll send another request to the command queue to read that result array back into local storage. From there, we'll be able to print the results to screen.<br /><br /><script src="https://gist.github.com/tuttlem/7675493.js"></script> Fantastic. Everything's on screen now, we can see the results. All we'll do from here is clean up our mess and get out.<br /><script src="https://gist.github.com/tuttlem/7675542.js"></script> <br />What a marathon! Hopefully you've learnt something from this post. It's a lot to take in to get a "Hello, World" level application up and running.<br /><div><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/25/setup-debian-for-opencl-development/">
        Setup Debian for OpenCL Development
      </a>
    </h1>

    <span class="post-date">25 Nov 2013</span>

    <h1>Setup Debian for OpenCL Development</h1>
<div class='post'>
<h3>Introduction</h3><div><a href="http://www.khronos.org/opencl/">OpenCL</a> (or Open Computing Language) is a framework that allows you to write code across different connected devices to your computer. Code that you write can execute on CPUs, GPUs, DPSs amongst other pieces of hardware. The framework itself is a standard that puts the focus on running your code across these devices but also emphasises parallel computing.</div><div><br /></div><div>Today's post will just be on getting your development environment setup on Debian Wheezy to start writing some code.</div><div><br /></div><h3>Installation</h3><div>The installation process is pretty straight forward, but there are some choices in libraries. The major vendors (Intel, NVIDIA and AMD) all have development libraries that are installable from Debian's package repository. There's plenty of banter on the internet as to who's is better for what purpose.</div><div><br /></div><div>First off, we need to install the header files we'll use to create OpenCL programs.</div><div><br /><pre class="brush: shell">$ sudo apt-get install opencl-headers</pre><br /></div><div>This has now put all of the development headers in place for you to compile some code.<br /><br /><pre class="brush: plain">$ ls -al /usr/include/CL<br />total 1060<br />drwxr-xr-x  2 root root   4096 Nov 25 22:51 .<br />drwxr-xr-x 56 root root   4096 Nov 25 22:51 ..<br />-rw-r--r--  1 root root   4859 Nov 15  2011 cl_d3d10.h<br />-rw-r--r--  1 root root   4853 Apr 18  2012 cl_d3d11.h<br />-rw-r--r--  1 root root   5157 Apr 18  2012 cl_dx9_media_sharing.h<br />-rw-r--r--  1 root root   9951 Nov 15  2011 cl_ext.h<br />-rw-r--r--  1 root root   2630 Nov 17  2011 cl_gl_ext.h<br />-rw-r--r--  1 root root   7429 Nov 15  2011 cl_gl.h<br />-rw-r--r--  1 root root  62888 Nov 17  2011 cl.h<br />-rw-r--r--  1 root root 915453 Feb  4  2012 cl.hpp<br />-rw-r--r--  1 root root  38164 Nov 17  2011 cl_platform.h<br />-rw-r--r--  1 root root   1754 Nov 15  2011 opencl.h<br /></pre><br />Secondly, we need to make a choice in what library we'll use:<br /><br />The <b>amd-opencl-dev </b>package will install AMD's implementation, which you can read up on <a href="http://developer.amd.com/resources/heterogeneous-computing/opencl-zone/">here</a>. NVIDIA's package is installable through the <b>nvidia-opencl-dev</b>&nbsp;package which you can read up on <a href="https://developer.nvidia.com/opencl">here</a>. Finally, Intel's implementation is available through the <b>beignet-dev</b>&nbsp;package and you can read up on their implementation <a href="http://software.intel.com/en-us/vcsource/tools/opencl">here</a>.<br /><br />I went with AMD's.<br /><br /><pre class="brush: shell">$ sudo apt-get install amd-opencl-dev</pre><br />From here, it's time to write some code. I'll have some more blog posts on the way which will be walk-throughs for your first applications.<br /><br /><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
  <div class="post">
    <h1 class="post-title">
      <a href="/2013/11/24/installing-a-single-node-hadoop-server-on-debian-wheezy/">
        Installing a Single Node Hadoop Server on Debian Wheezy
      </a>
    </h1>

    <span class="post-date">24 Nov 2013</span>

    <h1>Installing a Single Node Hadoop Server on Debian Wheezy</h1>
<div class='post'>
Today's post is just a run sheet of steps to take to get a single-node <a href="http://hadoop.apache.org/">Hadoop</a> server up and running on <a href="https://wiki.debian.org/DebianWheezy">Debian Wheezy</a>. Keep in mind, this guide is for the 1.x.x series release of Hadoop.<br /><br />1. Install java 6 jdk (<a href="http://ddmytrenko.blogspot.com.au/2012/02/installing-sun-java-6-jdk-on-debian.html">http://ddmytrenko.blogspot.com.au/2012/02/installing-sun-java-6-jdk-on-debian.html</a>)<br /><br />Add a line to apt sources for "squeeze non-free"<br /><br /><pre class="brush: shell">$ sudo apt-get update<br />$ sudo apt-get install sun-java6-jdk<br />$ sudo update-java-alternatives -s java-6-sun<br /></pre><br />2. Add a haddop user<br /><br /><pre class="brush: shell">$ sudo addgroup hadoop<br />$ sudo adduser --ingroup hadoop hduser<br /></pre><br />3. Disable ipv6: add the following to the end of /etc/sysctl.conf<br /><br /><pre class="brush: plain">#disable ipv6<br />net.ipv6.conf.all.disable_ipv6 = 1<br />net.ipv6.conf.default.disable_ipv6 = 1<br />net.ipv6.conf.lo.disable_ipv6 = 1<br /></pre><br />4. Add the following to ~/.bashrc<br /><br /><pre class="brush:plain"># Set Hadoop-related environment variables<br />export HADOOP_HOME=/opt/hadoop<br /><br /># Set JAVA_HOME (we will also configure JAVA_HOME directly for Hadoop later on)<br />export JAVA_HOME=/opt/jvm/jdk1.6.0_38<br /><br /># Add Hadoop bin/ and JAVA bin/ directory to PATH<br />export PATH=$PATH:$HADOOP_HOME/bin<br />export PATH=$PATH:$JAVA_HOME/bin<br /></pre><br />5. Download the "bin" flavour from here: <a href="http://apache.mirror.uber.com.au/hadoop/common/stable/">http://apache.mirror.uber.com.au/hadoop/common/stable/</a> extract it, move it into /opt under the name "hadoop"<br /><br />6. hadoop-env.sh<br /><br />Open opt/hadoop/conf/hadoop-env.sh and set the JAVA_HOME environment variable to the Sun JDK/JRE 6 directory.<br /><br /><pre class="brush:plain"># The java implementation to use.&nbsp; Required.<br /># export JAVA_HOME=/usr/lib/j2sdk1.5-sun<br />to<br />export JAVA_HOME=/opt/lib/jvm/java-6-sun<br /></pre><br />7. core-site.xml<br /><br />This is where Hadoop stores its Data.<br />/opt/hadoop/conf/core-site.xml<br /><br /><pre class="brush:plain">&lt;!-- In: conf/core-site.xml --&gt;<br />&lt;!-- In: conf/core-site.xml --&gt;<br />&lt;property&gt;<br />&nbsp; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;<br />&nbsp; &lt;value&gt;/app/hadoop/tmp&lt;/value&gt;<br />&nbsp; &lt;description&gt;A base for other temporary directories.&lt;/description&gt;<br />&lt;/property&gt;<br /><br />&lt;property&gt;<br />&nbsp; &lt;name&gt;fs.default.name&lt;/name&gt;<br />&nbsp; &lt;value&gt;hdfs://localhost:54310&lt;/value&gt;<br />&nbsp; &lt;description&gt;The name of the default file system.&nbsp; A URI whose<br />&nbsp; scheme and authority determine the FileSystem implementation.&nbsp; The<br />&nbsp; uri's scheme determines the config property (fs.SCHEME.impl) naming<br />&nbsp; the FileSystem implementation class.&nbsp; The uri's authority is used to<br />&nbsp; determine the host, port, etc. for a filesystem.&lt;/description&gt;<br />&lt;/property&gt;<br /></pre>We need to create this directory and set ownership correctly:<br /><br /><pre class="brush:shell">$ mkdir -p /app/hadoop/tmp<br />$ chown hduser:hadoop /app/hadoop/tmp<br /></pre><br />8. mapred-site.xml<br /><br />vim mapred-site.xml<br /><br /><pre class="brush:plain">&lt;!-- In: conf/mapred-site.xml --&gt;<br />&lt;property&gt;<br />&nbsp; &lt;name&gt;mapred.job.tracker&lt;/name&gt;<br />&nbsp; &lt;value&gt;localhost:54311&lt;/value&gt;<br />&nbsp; &lt;description&gt;The host and port that the MapReduce job tracker runs<br />&nbsp; at.&nbsp; If "local", then jobs are run in-process as a single map<br />&nbsp; and reduce task.<br />&nbsp; &lt;/description&gt;<br />&lt;/property&gt;<br /></pre><br />9. hdfs-site.xml<br /><br />vim hdfs-site.xml<br /><br /><pre class="brush:plain">&lt;!-- In: conf/hdfs-site.xml --&gt;<br />&lt;property&gt;<br />&nbsp; &lt;name&gt;dfs.replication&lt;/name&gt;<br />&nbsp; &lt;value&gt;1&lt;/value&gt;<br />&nbsp; &lt;description&gt;Default block replication.<br />&nbsp; The actual number of replications can be specified when the file is created.<br />&nbsp; The default is used if replication is not specified in create time.<br />&nbsp; &lt;/description&gt;<br />&lt;/property&gt;<br /></pre><br />10. Starting Hadoop (as hduser)<br /><br />Format the namenode<br /><pre class="brush:shell">$ /opt/hadoop/bin/hadoop namenode -format</pre><br />Start hadoop<br /><pre class="brush:shell">$ /opt/hadoop/bin/start-all.sh</pre><br />Up and running:<br /><br />NameNode daemon<br /><a href="http://localhost:50070/">http://localhost:50070/</a><br /><br />JobTracker daemon<br /><a href="http://localhost:50030/">http://localhost:50030/</a><br /><br />TaskTracker daemon<br /><a href="http://localhost:50060/">http://localhost:50060/</a><br /><br /></div>
<h2>Comments</h2>
<div class='comments'>
</div>

  </div>
  
</div>

<div class="pagination">
  
    <a class="pagination-item older" href="/page7">Older</a>
  
  
    
      <a class="pagination-item newer" href="/page5">Newer</a>
    
  
</div>
      </div>
    </div>

  </body>
</html>
