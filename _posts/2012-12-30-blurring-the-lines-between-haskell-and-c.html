---
layout: post
title: Blurring the lines between Haskell and C
date: 2012-12-30
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>Being able to use parts of code that you have written in different languages in your environment of choice is a great productivity booster. For those particular problems you can really pick the tool that you need.</div><div><br /></div><div>Haskell and C are no exception to this. The Haskell website has a <a href="http://www.haskell.org/haskellwiki/Calling_Haskell_from_C">great little write-up</a> on the topic. In today's post, I'm going to run you through the steps that I followed to get this running.</div><div><br /></div><h3>Write your Haskell</h3><div>The compilation process depends on your Haskell code being written first as GHC will generate some stub code for you.</div><div><br /></div><div>Here's a very simple and crude prime number tester:</div><div><br /><script src="https://gist.github.com/4410052.js"></script></div><div><br />Ignoring my method of primes testing, you can see some interesting pieces in this Haskell source. On the first line we're enabling a GHC extension for the ForeignFucntionInterface. This allows us to export symbols to other languages. We have our implementation actually in the function "is_prime" with "is_prime_hs" being the callable wrapper from outside, in this case C. The last line actually exports our wrapper as a callable function.<br /><br /><h3>Haskell compilation</h3></div><div>You've got your Haskell module ready for compilation, but it's going to be a little bit different. This source is supporting another application rather than containing a main function of its own.</div><div><br /><pre>$ ghc -c -O prime.hs</pre></div><div><br />This command will compile our file only "-c" and optimise "-O". A stub header file is generated for us (thanks to our FFI instructions on the first line of our Haskell file) that we can include in our main program.<br /><br /><h3>Write your C</h3></div><div>It's now time to call our prime function. There is a little bit of administration "fluff" that we have to go through in order to get there, but it's really not much to worry about. Take note that we're including our stub header file that was generated for us in our Haskell compilation step.</div><div><br /><script src="https://gist.github.com/4410375.js"></script></div><div><br /></div><div><br /></div><div>So that's pretty straight-forward C code in the end. It's a little awkward at first to look at the #define rigmarole at the top of the file, but you'll soon see straight past it.<br /><br />You can see at the top of the file that we've got an external symbol representing the module, "Primes". This is used as a secondary initialisation step after we start up FFI (with hs_init). The call to hs_add_root is the extra initialisation required (per module we import - <a href="http://hackage.haskell.org/trac/ghc/ticket/3252">I'm led to believe</a>) that we do for GHC's sake.<br /><br />Your C code is written, it's now time to compile, link and execute! Compilation to produce an executable looks like this.<br /><br /><pre>$ ghc --make -no-hs-main -optc-O call_prime.c Prime -o test</pre><br />We're telling ghc that we want to make (--make) our executable (-o test) that doesn't have a main routine in haskell source (-no-hs-main) and optimised by the c compiler (-optc-O).<br /><br />We should have an executable, ready to go:<br /><br /><pre>$ ./test<br />is 13 prime? 1<br />is 21 prime? 0<br /></pre><br />It's not fireworks, but it's functional.<br /><br /><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
