---
layout: post
title: GLFW-b from Haskell
date: 2013-01-14
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>I've previously posted about getting up and running with OpenGL from Haskell <a href="http://cogsandlevers.blogspot.com.au/2013/01/opengl-glut-haskell.html">here</a>, but I've since learned of <a href="http://www.glfw.org/">GLFW</a>&nbsp;and some of its bindings into Haskell in the form of <a href="http://hackage.haskell.org/package/GLFW">glfw</a>&nbsp;and <a href="http://hackage.haskell.org/package/GLFW-b">glfw-b</a>. The posts that I have been reading seem to present glfw-b with a more Haskell-style interface so this is the binding choice that I've decided to go with.</div><div><br /></div><div>Today, I'll walk you through a very simple application that will present you with a 2D drawing surface ready to go. It will demonstrate how to respond to window resize events, key input, GL setup and teardown.</div><div><br /></div><div>There is some great resources around for these bindings. The <a href="http://www.haskell.org/haskellwiki/GLFW">Haskell Wiki</a> has an article on GLFW with a link to some GLFW-b ports of the <a href="http://nehe.gamedev.net/">nehe tutorials</a> <a href="http://hackage.haskell.org/package/nehe-tuts">here</a>.</div><div><br /></div><div>The code for this is available in my <a href="https://github.com/tuttlem/haskets">haskets</a> repository. Here's the <a href="https://raw.github.com/tuttlem/haskets/master/glfw/First.hs">direct link</a> to the file we'll be analysing.&nbsp;</div><div><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-aPw7-CRRMjw/UPPCxR9z0dI/AAAAAAAAAk4/J2ZUX2_6jHc/s1600/Screen+Shot+2013-01-14+at+6.32.45+PM.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="326" src="http://1.bp.blogspot.com/-aPw7-CRRMjw/UPPCxR9z0dI/AAAAAAAAAk4/J2ZUX2_6jHc/s400/Screen+Shot+2013-01-14+at+6.32.45+PM.png" width="400" /></a></div><div><br /></div><h3>The code</h3><div>First off, we'll take a look at what's being imported into this application.</div><div><br /><script src="https://gist.github.com/4528618.js"></script></div><div><br />The GLFW bindings come into the program on the first line. This really is the bridge between OpenGL and your presentation layer to get a window running and some sort of eventing communication being routed into your program.<br /><br />OpenGL and GLU raw are just as they say. You'll see code in this tutorial that looks directly from these APIs. The names aren't lying.<br /><br />Finally here we just have some program management handling exit codes and execution life.<br /><br />After we've imported everything that we need, it's time to setup the GL scene as if all of the window management stuff has already been done.<br /><br /><script src="https://gist.github.com/4529208.js"></script> These are all looking like very natural GL calls. The code commentary should guide you through what's happening here.<br /><br />When the window that's hosting our application changes dimensions, our program will be sent a message updating us on what the new dimensions are. Here's how we adapt to these changes in 2D.<br /><br /><script src="https://gist.github.com/4529230.js"></script> These are all standard OpenGL calls also. The signature of the resize function delivers us the updated width and height to use.<br /><br />Drawing our scene is extremely basic. We're clearing the screen (to black, as above). That's it.<br /><script src="https://gist.github.com/4529240.js"></script> <br /><br />'nuff said. To destroy all of the resources we've utilised in the target windowing system we issue some teardown functions.<br /><br /><script src="https://gist.github.com/4529256.js"></script> <br />Handling keyboard input is just a matter of using KeyCallback.<br /><br />The teardown handler is entered when the escape key is hit. Any other key is ignored.<br /><script src="https://gist.github.com/4529268.js"></script> All of these function definitions are really no good to us unless we can bind them into the framework. This will bring all of these functions to life. The next block of code is the main program for the application. It'll be heavily commented.<br /><br /><script src="https://gist.github.com/4529317.js"></script> So, that's it for GLFW-b for Haskell. Not so intimidating and actually quite inviting to develop against!</div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
