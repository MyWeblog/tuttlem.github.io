---
layout: post
title: Monads
date: 2013-01-28
comments: false
---

<h1>{{ page.title }}</h1>
<div class='post'>
<h3>Introduction</h3><div>Following on from my previous posts about <a href="http://cogsandlevers.blogspot.com.au/2013/01/functors-in-haskell.html">functors</a>, <a href="http://cogsandlevers.blogspot.com.au/2013/01/applicative-functors-in-haskell.html">applicative functors</a> and <a href="http://cogsandlevers.blogspot.com.au/2013/01/applying-applicative.html">applying applicative</a>&nbsp;it would only be natural for me to post a follow up on the topic of Monads. Monads take shape very similarly to applicative functors so for this post to make sense, I suggest you read the previous articles so that you have a chance to follow along.</div><div><br /></div><h3>What is a Monad?</h3><div>At a code level, a Monad is a type that is an instance of the <a href="http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Monad">Monad</a> type class. At a concept level a Monad allows you to provide a function that is context-unaware to operate over values that are wrapped in a context. Immediately, you'd think that this is weaker functionality that what was defined for applicative functors - and you'd be right in thinking so, but Monads do provide a very natural way to write code against our types.</div><div><br /></div><div>Here is the type definition for a Monad.</div><div><br /><script src="https://gist.github.com/4654705.js"></script></div><div><br />Moving through all of the defined functions, you first see "return". "return" is the same as "pure" which we defined when making an applicative functor. "return"'s role in this type is to lift a value into a context. The next function you see is "&gt;&gt;=" which is pronounced "bind". This is the major difference right here. The "bind" function is what takes a value wrapped in a context <b>"m a" </b>and takes a function with a parameter of <b>"a" </b>returning a wrapped b as <b>"m b"</b>, with the function returning a b in a context "<b>m b"</b>.<br /><br />The remaining two operations are rarely delved into as their default implementations suffice majority of scenarios.<br /><br /><h3>Laws</h3><div>There are some laws that need to be abided by when implementing Monads.</div><div><br /></div><div>Left Identity suggests that&nbsp;</div><div><br /></div><div><pre>x &gt;&gt;= f is the same thing as f x&nbsp;</pre><br />Right Identity suggests that<br /><br /><pre>m &gt;&gt;= return is the same as m</pre><br />Associativity suggests that<br /><br /><pre>(m &gt;&gt;= f) &gt;&gt;= g is the same as m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</pre><br />Such that it shouldn't matter how these calls are nested together.</div><h3>Custom context</h3><div>Applying this knowledge to our rather useless example "CustomContext" discussed <a href="http://cogsandlevers.blogspot.com.au/2013/01/applying-applicative.html">here</a>, we can make this type a monad with the following definition.</div><div><br /><script src="https://gist.github.com/4654745.js"></script></div><div><br /></div>Ok, so - as prophesied "return" is doing the same thing as "pure" did for us - it's just lifting a plain value into our context. "&gt;&gt;=" or "bind" on the other hand is taking the value out of its context and applying a function to it.<br /><br />We can check out our bind implementation in action with the following simple examples.<br /><br /><pre>λ&gt; CustomContext 3 &gt;&gt;= \x -&gt; return (x + 1)<br />CustomContext 4<br />λ&gt; CustomContext "Hello" &gt;&gt;= \x -&gt; return (x ++ " World!")<br />CustomContext "Hello World!"<br /></pre><br />Our value is having a function applied to it. Values are getting de-contexted, worked-on than re-contexted. Pretty straight forward.<br /><br />To show you how "&gt;&gt;=" can work for us, I've created a function that will accumulate even numbers as they are received into it. If an odd number is encountered, the accumulated total get wiped back to zero until conditions are met to have another two consecutive calls with even numbers.<br /><br />Here's how the function looks.<br /><br /><script src="https://gist.github.com/4654909.js"></script> <br />Using guards, we filter out odd numbers sending the result back to zero otherwise we continue to accumulate. Note how the inputs are just plain integers but the output is an integer wrapped in one of our CustomContext types. With the use of "&gt;&gt;=" the following calls are possible.<br /><br /><pre>λ&gt; accumEven 0 2<br />CustomContext 2<br />λ&gt; accumEven 0 2 &gt;&gt;= accumEven 4<br />CustomContext 6<br />λ&gt; accumEven 0 2 &gt;&gt;= accumEven 4 &gt;&gt;= accumEven 7<br />CustomContext 13<br /></pre><br />First of all, we're freely using wrapped and un-wrapped contexts thanks to that bind operator. More interestingly (and demonstrative to our purposes here), the last example appears to be in error, but it's really not. Think about it this way.<br /><br /><pre>accumEven 0 2 = 2<br />accumEven 4 2 = 6<br />accumEven 6 7 = 13<br /></pre><br />So you can see here that the next sub-sequent call to "accumEven" would finish with a 0 (zero) value as the 13 would be carried onto the next call and would be tested for evenness. Even if this isn't the best example, it still demonstrates how bind is sending information between the calls.<br /><br /><h3>do Notation</h3><div>Another nicety when working with Monads is "do" notation. "do" notation allows you to clean up a lot of the boilerplate that builds up around the functionality you write when working with monadic values. Here's a very simple function that builds a CustomContext from two other CustomContexts by adding them.</div><div><br /><script src="https://gist.github.com/4655091.js"></script></div><div><br /></div>You can see how things start to get a bit gnarly once you chain more calls together. Using "do" notation, this gets cleaned up pretty well. The above can be re-written like so.<br /><br /><script src="https://gist.github.com/4655121.js"></script> <br />That's so much easier to read! There's "do" notation at work for you, anyway.<br /><br />Well, that's all there is for Monads right now. As soon as I try something useful with them, I'll post a follow-up article of Monads in Application.<br /><br /></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
