<h1>Os Kernel Development The Bootloader</h1>
<div class='post'>
<h3>Introduction</h3><div>The first step in the execution process (once the machine has finished its PowerOnStartTest boot) is the loading and execution of a small program called the bootloader. It's responsible for getting enough logic into the computers memory to get your operating system started.</div><div><br /></div><div>Today's post will focus on this bootloader program and getting you over into C land where you can complete the majority of your operating system.</div><div><br /></div><div>As I'd described in the&nbsp;<a href="http://cogsandlevers.blogspot.com.au/2012/12/os-kernel-development-environment.html">first post</a> of this series, I'll be making some assumptions on the directions of the operating system's tools. Some assumptions that will that has some serious implications in the development of the bootloader are:</div><div><ul><li>Will the bootloader support a multi-boot loader?<br /><i>Yes. We'll be using GRUB.</i></li><li>What platform will we assume that we're on?<br /><i>This is important because the bootloader must be written in the platform's native instruction set to do anything of value. We'll be assuming the intel platform.</i></li></ul></div><div><br /></div><h3>Bootloader execution</h3><div>Shortly after your IBM-PC compatible computer starts, it's starts in real mode. You can find out more information about the booting process from <a href="http://en.wikipedia.org/wiki/Booting#Boot_sequence_of_IBM-PC_compatibles">this article</a>&nbsp;as it will take you through the particulars. We're using GRUB so we're abstracted away from a lot of these details. The floppy disk image will have GRUB configured to run our kernel.</div><div><br /></div><div>First up, we need to make a few items visible to the linker and let our loader know that the main routine is "somewhere else".<br /><br /><script src="https://gist.github.com/4449471.js"></script> <br />"loader" is our bootloader's entry point to start executing, "magic" is a special number that our multi-boot loader will look out for, "mbd" is a pointer to a special structure containing multi-boot information that can give your kernel context of its execution and "kmain" is our external kernel code (that will be implemented in C).<br /><br />Next up, we'll look at the code that's executing.<br /><br /><script src="https://gist.github.com/4449491.js"></script></div><div><br />First job is to setup a stackframe. This is done by pre-allocating some space within this module. All were doing is just pushing "esp" by the location of the pre-allocated stack page with an offset of a pre-determined size.<br /><br />Some assumptions are made when GRUB hands control over to our bootloader. For instance, eax will hold the multi-boot magic number and ebx will hold the multiboot structure. These are saved off into the linker visible locations "magic" and "mbd"&nbsp;respectively. Finally we call "kmain" to get the party started.<br /><br />It's assumed that the kernel will never return, so we put a halt loop at the end of it just to we don't go running off into memory executing every instruction known to mankind.<br /><h3>The birth of the Kernel</h3>The most important part to take note of is that we're now in C land. This is quite a simple routine (for the time being) taking the following form.<br /><br /><script src="https://gist.github.com/4449518.js"></script> <br />Excellent, well, non-functional, but we're here. You can see that we're given access to the "magic" and "mbd" values that we were playing around with in the boot loader. The all important magic number test will determine if we've legitimately come from GRUB.<br /><br /><h3>Linking it all together</h3></div><div>We've got a partially complex job now of making sure the gobs of binary that are produced when building these files are put in place correctly for us to execute.</div><div></div><div><br />We provide gcc during the compilation process with the following flags to make sure the binary produced is as plain-jane as possible.<br /><br /><pre>-Wall          (all warnings)<br />-Wextra        (enable extra warning flags)<br />-nostdlib      (do not use the standard libraries during linking)<br />-nostartfiles<br />-nodefaultlibs<br />-fno-builtin   (turn off builtin prefix functions)<br />-m32           (generate 32bit code)</pre><br />The linker script is all that is left to describe to the preparation process on how to put our kernel together. Here's how it looks.<br /><br /><script src="https://gist.github.com/4449589.js"></script> <br />Reading this from top to bottom you can see that we're defining our entry point as "loader" (you would have seen that in the bootloader assembly above). We're aligning all of our sections (text, rodata and data) on 4096 (0x1000) byte boundaries. We have a base address (where the code will be loaded) of 0x00100000 as well as stack placement. There are great articles all over the web on the topic of linking, my&nbsp;favorite&nbsp;<a href="http://www.lurklurk.org/linkers/linkers.html">here</a>.<br /><br />That's it. This is the bootloader handoff from GRUB in a nutshell (a largish nutshell). Check out <a href="https://github.com/tuttlem/phoenix">Phoenix</a>&nbsp;in my GitHub&nbsp;repository&nbsp;for the full source.<br /><br />For some even more advanced information check out this tutorial on <a href="http://www.jamesmolloy.co.uk/tutorial_html/">Rolling Your Own Unix Clone</a>.<br /><br /></div><div></div></div>
<h2>Comments</h2>
<div class='comments'>
</div>
